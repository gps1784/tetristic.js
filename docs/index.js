/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/board.js":
/*!**********************!*\
  !*** ./src/board.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* tetristic/src/board.js\r\n *\r\n */\r\n\r\nconst Tetromino = __webpack_require__(/*! ./tetromino.js */ \"./src/tetromino.js\");\r\n\r\nclass Board {\r\n  /* OBJECT MANAGEMENT\r\n   *\r\n   */\r\n\r\n  constructor(\r\n    canvasObj,\r\n    width = 10,\r\n    height = 20\r\n  ) {\r\n    // setup the canvas and scaling\r\n    this.screen = canvasObj.getContext('2d');\r\n    this.width  = width;\r\n    this.height = height;\r\n    // move the origin from the top left to the bottom left\r\n    this.screen.resetTransform();\r\n    this.screen.translate(0, this.screen.canvas.height);\r\n    this.scale  = Math.min(\r\n      Math.floor(this.screen.canvas.width  / (this.width + 6)),\r\n      Math.floor(this.screen.canvas.height / this.height),\r\n    );\r\n    // initialize the starting pieces and score\r\n    this.score  = 0;\r\n    this.cells  = Array.from( new Array(width), function() { // column/x\r\n      return Array.from( new Array(height), function() { // row/y\r\n        return null;\r\n      }); // row\r\n    }); // column\r\n    this.active = Tetromino.shapes.random(this);\r\n    this.next   = Tetromino.shapes.random(this, this.active);\r\n    // render the board\r\n    //this.render();\r\n  } // Board.constructor()\r\n\r\n  clone() {\r\n    let orig     = this;\r\n    let retval   = new Board(orig.screen.canvas, orig.width, orig.height);\r\n    retval.cells = Array.from( new Array(orig.width), function(column, cIndex) { // column/x\r\n      return Array.from( orig.cells[cIndex], function(cell) { // row/y\r\n        return cell ? cell.clone(retval) : null;\r\n      }); // row\r\n    }); // column\r\n    retval.active = orig.active.clone(retval);\r\n    retval.next   = orig.next.clone(retval);\r\n    return retval;\r\n  } // Board#clone()\r\n\r\n  /* RENDERING CODE\r\n   *\r\n   */\r\n\r\n  render() {\r\n    this.renderBackground();\r\n    this.renderForeground();\r\n    this.renderActive();\r\n    this.renderNext();\r\n    this.renderScore();\r\n  } // Board#render()\r\n\r\n  renderBackground(\r\n    scale     = null,\r\n    x         = 0,\r\n    y         = 0,\r\n    width     = this.width,\r\n    height    = this.height,\r\n    fillStyle = 'rgb(150, 150, 150)'\r\n  ) {\r\n    scale = scale || this.scale;\r\n    this.screen.fillStyle = fillStyle;\r\n    for (let col = x; col < width + x; col++) {\r\n      for (let row = y; row < height + y; row++) {\r\n        let _x = col * scale;\r\n        let _y = row * scale * -1;\r\n        this.screen.fillRect(_x+1, _y-1, scale-2, -(scale-2));\r\n      } // for row\r\n    } // for col\r\n    return this; // chainable\r\n  } // Board#renderBackground()\r\n\r\n  renderForeground(\r\n    scale  = null,\r\n    x      = 0,\r\n    y      = 0,\r\n    width  = this.width,\r\n    height = this.height\r\n  ) {\r\n    scale = scale || this.scale;\r\n    for (let col of this.cells) {\r\n      for (let cell of col) {\r\n        if (cell !== null) {\r\n          cell.render();\r\n        } // if cell\r\n      } // for cell of col\r\n    } // for col of this.cells\r\n    return this; // chainable\r\n  } // Board#renderForeground()\r\n\r\n  renderActive(\r\n    scale = null\r\n  ) {\r\n    scale = scale || this.scale;\r\n    this.active.render();\r\n    return this; // chainable\r\n  } // Board#renderActive()\r\n\r\n  renderNext(\r\n    scale = null\r\n  ) {\r\n    scale = scale || this.scale;\r\n    this.screen.font = this.scale + 'px monospace'; // 'dynamic' font!\r\n    this.screen.textBaseline = 'bottom';\r\n    this.renderBackground(scale, 11, 13, 4, 4);\r\n    this.screen.fillText('NEXT', 11*scale, -17*scale);\r\n    this.next.render(13, 14);\r\n    return this; // chainable\r\n  } // Board#renderNext()\r\n\r\n  renderScore(\r\n    scale = null\r\n  ) {\r\n    scale = scale || this.scale;\r\n    this.screen.fillStyle = 'rgb(255, 255, 255)';\r\n    this.screen.fillRect(scale*11, scale*-11, scale*4, scale*1);\r\n    this.screen.fillStyle = 'rgb(150, 150, 150)';\r\n    this.screen.fillText(\"CLEARED:\", scale*11, scale*-11);\r\n    this.screen.fillText(this.score, scale*11, scale*-10);\r\n    return this; // chainable\r\n  } // Board#renderScore()\r\n\r\n  /* GAMEPLAY LOGIC\r\n   * clearing lines, testing rows and columns, getting and setting cell values\r\n   */\r\n\r\n  clearLines() {\r\n    for (let row = this.height - 1; row >= 0; row--) {\r\n      if (this.rowIsFull(row)) {\r\n        this.score++;\r\n        // clear the line if filled\r\n        for (let col = 0; col < this.width; col++) {\r\n          this.cells[col][row] = null;\r\n        } // for col\r\n        // for each row, translate the cells, then move them down in this.cells\r\n        for (let rowAbove = row + 1; rowAbove < this.height; rowAbove++) {\r\n          for (let col = 0; col < this.width; col++) {\r\n            if (this.cells[col][rowAbove] !== null) {\r\n              this.cells[col][rowAbove].translate(0, -1);\r\n            }\r\n            this.cells[col][rowAbove - 1] = this.cells[col][rowAbove];\r\n            this.cells[col][rowAbove]     = null;\r\n          } // for col\r\n        } // for rowAbove\r\n      } // if rowIsFull\r\n    } // for row\r\n  } // Board#clearLines()\r\n\r\n  getCell(colX, rowY) {\r\n    return this.cells[colX][rowY];\r\n  } // Board#getCell()\r\n\r\n  rowIsFull(row) {\r\n    let full = true;\r\n    for (let col = 0; col < this.width; col++) {\r\n      if (this.cells[col][row] === null) {\r\n        full = false;\r\n        break;\r\n      } // if cell === null\r\n    } // for col\r\n    return full;\r\n  } // Board#rowIsFull()\r\n\r\n  rowIsEmpty(row) {\r\n    let empty = true;\r\n    for (let col = 0; col < this.width; col++) {\r\n      if (this.cells[col][row] !== null) {\r\n        empty = false;\r\n        break;\r\n      } // if cell === null\r\n    } // for col\r\n    return empty;\r\n  } // Board#rowIsEmpty()\r\n\r\n  play() {\r\n    // hacky workaround for gaining focus https://stackoverflow.com/questions/15631991#16492878\r\n    this.screen.canvas.tabIndex  = 0;\r\n    this.screen.canvas.onkeydown = this.onKeyDown.bind(this);\r\n    this.update(true);\r\n  } // Board#play()\r\n\r\n  onKeyDown(event) {\r\n    switch (event.key) {\r\n      case 'q': // CCW\r\n        this.active.rotateCCW();\r\n      break;\r\n      case 'e': // CW\r\n        this.active.rotateCW();\r\n      break;\r\n      case 'a':\r\n      case 'ArrowLeft': // left\r\n        this.active.translate(-1, 0); // dx, dy\r\n      break;\r\n      case 'w':\r\n      case 'ArrowUp': // up\r\n        while (!this.active.canDecompose()) {\r\n          this.active.translate(0, -1); // dx, dy\r\n        }\r\n        this.active.decompose();\r\n        this.active = null;\r\n      break;\r\n      case 'd':\r\n      case 'ArrowRight': // right\r\n        this.active.translate(1, 0); // dx, dy\r\n      break;\r\n      case 's':\r\n      case 'ArrowDown': // down\r\n        // if this piece cannot move downward (latched)\r\n        if (!this.active.translate(0, -1)) {\r\n          // then decompose it and prepare a new one\r\n          this.active.decompose();\r\n          this.active = null;\r\n        }\r\n      break;\r\n      default:\r\n        console.log(`Pressed key: ${event.key}`);\r\n    } // switch event.keythis.screen.canvas\r\n  } // Board#onKeyDown()this.screen.canvas\r\n\r\n  update(\r\n    animate = false\r\n  ) {\r\n    // refill the next tetromino, if needed\r\n    if (this.active === null) {\r\n      this.active = this.next;\r\n      this.next   = Tetromino.shapes.random(this, this.active);\r\n    } // if this.active\r\n    this.clearLines();\r\n    this.render();\r\n    if (animate && !this.gameOver()) {\r\n      requestAnimationFrame(this.update.bind(this, animate));\r\n    } // if animate...\r\n  } // Board#update()\r\n\r\n  gameOver() {\r\n    if (!(this.rowIsEmpty(18) && this.rowIsEmpty(19))) {\r\n      console.log('GAME OVER\\nSCORE:', this.score);\r\n      this.screen.canvas.onkeydown = null;\r\n      return true;\r\n    }\r\n    return false;\r\n  } // Board#gameOver()\r\n} // class Board\r\n\r\nmodule.exports = Board;\r\n\n\n//# sourceURL=webpack://tetristic/./src/board.js?");

/***/ }),

/***/ "./src/heuristic/index.js":
/*!********************************!*\
  !*** ./src/heuristic/index.js ***!
  \********************************/
/***/ ((module) => {

eval("// tetristic/heuristic/index.js\r\n\r\n// All the heuristics here are normalized.\r\n// That is to say, they are bound to a range of either 0~1 or -1~1\r\n// depending on what is appropriate for our use case.\r\n// I do not want my factors and biases spiraling out of control here,\r\n// so we are normalizing the input of all heuristics.\r\n\r\nconst MAX_LINES_CLEARED_AT_ONCE = 4;\r\n\r\nconst Heuristic = {\r\n  sigmoid: function heuristicSigmoid(x) {\r\n    return (2 / (1 + Math.exp(x * -1)) - 1)\r\n  }, // sigmoid()\r\n\r\n  getHeightOfCol: function heuristicGetHeightOfCol(board, col) {\r\n    for (let row = board.height - 1; row >= 0; row--) {\r\n      if (board.getCell(col, row) !== null) {\r\n        return (row + 1);\r\n      }\r\n    } // for row\r\n    return 0;\r\n  }, // getHeightOfCol()\r\n\r\n  maxHeight: function heuristicMaxHeight(board) {\r\n    // start at the bottom, counting upward\r\n    // this will keep track of the highest populated row,\r\n    // where 0 is the ceiling and 20 is empty\r\n    board.active.decompose();\r\n    let retval = 0;\r\n    for (let row = 0; row < board.height; row++) {\r\n      for (let col = 0; col < board.width; col++) {\r\n        if (board.getCell(col, row) !== null) {\r\n          retval = row;\r\n          break; // skip the rest of this row\r\n        } // if board.getCell\r\n      } // for col\r\n    } // for row\r\n    // normalize this value 0 <=> 1\r\n    // (e.g. height 0 => 0% => 0.0, height 20 => 100% => 1.0)\r\n    retval = retval / board.height;\r\n    return retval;\r\n  }, // maxHeight()\r\n\r\n  sumOfHeight: function heuristicSumOfHeight(board) {\r\n    // start at the bottom, counting upward\r\n    // this will keep track of the highest populated row,\r\n    // where 0 is the ceiling and 20 is empty\r\n    board.active.decompose();\r\n    let retval = 0;\r\n    for (let col = 0; col < board.width; col++) {\r\n      retval += Heuristic.getHeightOfCol(board, col);\r\n    } // for col\r\n    retval = retval / (board.height * board.width);\r\n    return retval;\r\n  }, // sumOfHeight()\r\n\r\n  bumpiness: function heuristicBumpiness(board) {\r\n    board.active.decompose();\r\n    let retval = 0;\r\n    for (let col = 0; col < board.width - 1; col++) {\r\n      let current = Heuristic.getHeightOfCol(board, col);\r\n      let next    = Heuristic.getHeightOfCol(board, col+1);\r\n      retval += Math.abs(current - next);\r\n    } // for col\r\n    retval = retval / (board.height * (board.width - 1));\r\n    return retval;\r\n  }, // bumpiness()\r\n\r\n  newLinesCleared: function heuristicNewLinesCleared(board) {\r\n    // decompose the active block, test for lines cleared,\r\n    // then restore the board to its previous state\r\n    let retval = 0;\r\n    board.clearLines();\r\n    retval = board.score;\r\n    board.active.decompose();\r\n    retval = (board.score - retval) / MAX_LINES_CLEARED_AT_ONCE;\r\n    return retval;\r\n  }, // newLinesCleared()\r\n\r\n  list: [], // list\r\n}; // Heuristic\r\n\r\nHeuristic.list.push( Heuristic.maxHeight );\r\n//Heuristic.list.push( Heuristic.sumOfHeight );\r\nHeuristic.list.push( Heuristic.bumpiness );\r\nHeuristic.list.push( Heuristic.newLinesCleared );\r\n\r\nmodule.exports = Heuristic;\r\n\n\n//# sourceURL=webpack://tetristic/./src/heuristic/index.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("var Tetristic = {};\r\n\r\nTetristic.Board = __webpack_require__(/*! ./board.js */ \"./src/board.js\");\r\nTetristic.Network = __webpack_require__(/*! ./network/index.js */ \"./src/network/index.js\");\r\n\r\nwindow.onload = function() {\r\n  let board = new Tetristic.Board( document.getElementById('tetristic-board') );\r\n  let network = new Tetristic.Network( document.getElementById('tetristic-network'), 1);\r\n  board.play();\r\n  network.play(board);\r\n};\r\n\n\n//# sourceURL=webpack://tetristic/./src/index.js?");

/***/ }),

/***/ "./src/network/index.js":
/*!******************************!*\
  !*** ./src/network/index.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Heuristic = __webpack_require__(/*! ../heuristic/index.js */ \"./src/heuristic/index.js\");\r\nconst Board = __webpack_require__(/*! ../board.js */ \"./src/board.js\");\r\nconst Placement = __webpack_require__(/*! ../placement.js */ \"./src/placement.js\");\r\n\r\nclass Network {\r\n  constructor(canvasObj=null, depth=null, widths=null, weights=null, biases=null) {\r\n    this.screen = canvasObj.getContext('2d');\r\n    this.generate(depth, widths, weights, biases);\r\n    this.render();\r\n  } // constructor()\r\n\r\n  clone() {\r\n    new Network(this.screen.canvas, this.depth, this.widths, this.weights, this.biases);\r\n  } // clone()\r\n\r\n  generate(depth, widths, weights, biases) {\r\n    if (depth === null) {\r\n      this.depth = Math.floor(1 + Math.random() * 3); // 1 <=> 3 layers\r\n    } else {\r\n      this.depth = depth;\r\n    }\r\n\r\n    if (widths === null) {\r\n      this.widths = [];\r\n      let _lastLayerWidth = Heuristic.list.length;\r\n      for (let _layer = 0; _layer < this.depth - 1; _layer++) {\r\n        // this forces a layer to be between x0.5 <=> x1.5 the size of the last\r\n        let _newLayerWidth = Math.max( Math.floor( _lastLayerWidth * (0.5 + Math.random()) ), 2);\r\n        this.widths.push(_newLayerWidth);\r\n        _lastLayerWidth = _newLayerWidth;\r\n      } // for _layer\r\n      this.widths.push(1);\r\n    } else {\r\n      this.widths = widths;\r\n    }\r\n\r\n    if (weights === null) {\r\n      this.weights = [];\r\n      let _lastLayerWidth = Heuristic.list.length;\r\n      for (let _layer = 0; _layer < this.depth; _layer++) {\r\n        this.weights.push( new Array() );\r\n        for (let _node = 0; _node < this.widths[_layer]; _node++) {\r\n          this.weights[_layer].push( new Array() );\r\n          for (let _lastNode = 0; _lastNode < _lastLayerWidth; _lastNode++) {\r\n            this.weights[_layer][_node].push( (Math.random() * 2) - 1 ); // -1 <=> 1\r\n          } // for _lastNode\r\n        } // for _node\r\n        _lastLayerWidth = this.widths[_layer];\r\n      } // for _layer\r\n    } else {\r\n      this.weights = weights;\r\n    }\r\n\r\n    if (biases === null) {\r\n      this.biases = [];\r\n      for (let _layer = 0; _layer < this.depth; _layer++) {\r\n        this.biases.push( new Array() );\r\n        for (let _node = 0; _node < this.widths[_layer]; _node++) {\r\n          this.biases[_layer].push( (Math.random() * 2) - 1 ); // -1 <=> 1\r\n        } // for _node\r\n      } // for _layer\r\n    } else {\r\n      this.biases = biases;\r\n    }\r\n\r\n    this.values = new Array();\r\n    // input layer first\r\n    this.values.push( new Array() );\r\n    for (let _input = 0; _input < Heuristic.list.length; _input++) {\r\n      this.values[0].push(0); // value defaults to 0\r\n    } // for _input\r\n    // hidden/output layers\r\n    for (let _layer = 0; _layer < this.depth; _layer++) {\r\n      this.values.push( new Array() );\r\n      for (let _node = 0; _node < this.widths[_layer]; _node++) {\r\n        this.values[_layer+1].push(0); // value defaults to 0\r\n      } // for _node\r\n    } // for _layer\r\n\r\n    // how wide are the graphics for the neural network allowed to be?\r\n    this.widthScale = Math.floor(\r\n      // canvas width divided by the largest of either\r\n      // the widest point in the neural network or the starting inputs\r\n      this.screen.canvas.width / Math.max(...this.widths, Heuristic.list.length)\r\n    );\r\n    // how tall are the graphics for the neural network allowed to be?\r\n    this.heightScale = Math.floor(\r\n      // the input and output layers will always be visible, plus any hidden layers\r\n      this.screen.canvas.height / (this.depth + 1)\r\n    );\r\n  } // generate()\r\n\r\n  calculateNetwork(board) {\r\n    for (let _input = 0; _input < Heuristic.list.length; _input++) {\r\n      this.values[0][_input] = Heuristic.list[_input](board.clone());\r\n    } // for _input\r\n    for (let _layer = 0; _layer < this.depth; _layer++) {\r\n      for (let _node = 0; _node < this.widths[_layer]; _node++) {\r\n        let _sum = 0;\r\n        for (let _link = 0; _link < this.weights[_layer][_node].length; _link++) {\r\n          // this.values[_layer] is a bit of a trick...\r\n          // since ONLY values includes the input layer,\r\n          // we are reading the layer BEFORE the active layer\r\n          _sum += this.values[_layer][_link] * this.weights[_layer][_node][_link];\r\n        } // for _link\r\n        _sum += this.biases[_layer][_node];\r\n        this.values[_layer+1][_node] = Heuristic.sigmoid(_sum);\r\n      } // for _node\r\n    } // for _layer\r\n  } // calculateNetwork()\r\n\r\n  render() {\r\n    this.renderLinks();\r\n    this.renderNodes();\r\n  } // render()\r\n\r\n  renderNodes() {\r\n    // the inputs\r\n    for (let _input = 0; _input < Heuristic.list.length; _input++) {\r\n      this.renderNode(0, _input);\r\n    } // for _input\r\n    // the hidden/output layers\r\n    for (let _layer = 0; _layer < this.depth; _layer++) {\r\n      for (let _node = 0; _node < this.widths[_layer]; _node++) {\r\n        this.renderNode(_layer+1, _node);\r\n      } // for _node\r\n    } // for _layer\r\n  } // renderNodes()\r\n\r\n  renderNode(layer, node) {\r\n    // precalculate some scaling options\r\n    let scale  = Math.min(this.widthScale, this.heightScale);\r\n    let offset = Math.floor(scale / 4);\r\n    let x     = (node * scale) + offset;\r\n    let y     = (layer * scale) + offset;\r\n    // setup the canvas as we like it\r\n    this.screen.font         = '14px monospace';\r\n    this.screen.lineWidth    = 2;\r\n    this.screen.textAlign    = 'right';\r\n    this.screen.textBaseline = 'top';\r\n    this.screen.fillStyle    = 'rgb(255, 255, 255)';\r\n    this.screen.strokeStyle  = 'rgb(0, 0, 0)';\r\n    // draw the rectangle, then the text on top\r\n    this.screen.fillRect(x, y, offset*2, offset*2);\r\n    this.screen.strokeRect(x, y, offset*2, offset*2);\r\n    this.screen.fillStyle = this.calcColorRedBlackGreen(this.values[layer][node]);\r\n    this.screen.fillText(this.values[layer][node].toFixed(3), x + offset*2, y);\r\n  } // renderNode()\r\n\r\n  renderLinks() {\r\n    let scale = Math.min(this.widthScale, this.heightScale);\r\n    let offset = Math.floor(scale / 2);\r\n    for (let _layer = 0; _layer < this.depth; _layer++) {\r\n      for (let _node = 0; _node < this.widths[_layer]; _node++) {\r\n        let _start = {x: _node * scale, y: (_layer + 1) * scale};\r\n        for (let _link = 0; _link < this.weights[_layer][_node].length; _link++) {\r\n          let _end = {x: _link * scale, y: _layer * scale};\r\n          this.screen.lineWidth   = 5;\r\n          this.screen.strokeStyle = this.calcColorRedBlackGreen(this.weights[_layer][_node][_link]);\r\n          this.screen.beginPath();\r\n          this.screen.moveTo(_start.x + offset, _start.y + offset);\r\n          this.screen.lineTo(_end.x + offset, _end.y + offset);\r\n          this.screen.stroke();\r\n        } // for _link\r\n      } // for _node\r\n    } // for _layer\r\n  } // renderLinks()\r\n\r\n  calcColorRedBlackGreen(decimal) {\r\n    let red   = 0;\r\n    let blue  = 0;\r\n    let green = 0;\r\n    if (decimal < 0) { // red/black (based on 'crimson')\r\n      red   = Math.floor(decimal * -220);\r\n      blue  = Math.floor(decimal *  -20);\r\n      green = Math.floor(decimal *  -60);\r\n\r\n    } else { // green/black (based on 'sea green')\r\n      red   = Math.floor(decimal *  20);\r\n      blue  = Math.floor(decimal * 220);\r\n      green = Math.floor(decimal *  60);\r\n    }\r\n    return `rgb(${red},${blue},${green})`;\r\n  } // calcColorRedBlackGreen()\r\n\r\n  calcColorRedWhiteGreen() {} // calcColorRedWhiteGreen()\r\n\r\n  play(board) {\r\n    board.update();\r\n    new Placement(board, this).explore().animate();\r\n    this.render();\r\n  } // play()\r\n} // class Network\r\n\r\nNetwork.heuristic = Heuristic;\r\n\r\nmodule.exports = Network;\r\n\n\n//# sourceURL=webpack://tetristic/./src/network/index.js?");

/***/ }),

/***/ "./src/placement.js":
/*!**************************!*\
  !*** ./src/placement.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* tetristic/src/placement.js\r\n *\r\n */\r\n\r\nconst Node  = __webpack_require__(/*! ./placement/node.js */ \"./src/placement/node.js\");\r\n\r\nclass Placement {\r\n  constructor(board, neuralnet) {\r\n    this.board = board;\r\n    this.neuralnet = neuralnet;\r\n    // TODO: skipping redundant positions for now\r\n  } // Placement.constructor()\r\n\r\n  explore() {\r\n    console.log(`Finding possible moves for ${this.board.active.name}...`);\r\n    this.tree = Node.Root(this.board, this.neuralnet);\r\n    console.log(`Finding best fit for neural network...`);\r\n    let best = this.tree.explore(this.neuralnet);\r\n    console.log('Best move:', best);\r\n    return this;\r\n  } // Placement#explore()\r\n\r\n  animate(moves = this.tree.best.moves) {\r\n    let move = moves.shift();\r\n    move(this.board);\r\n    this.board.update();\r\n    if (moves.length > 0) {\r\n      requestAnimationFrame(this.animate.bind(this, moves));\r\n    } else {\r\n      this.board.active.decompose(this.board);\r\n      this.board.active = null;\r\n      this.board.update();\r\n      if (this.board.gameOver()) {\r\n        console.log(this.neuralnet);\r\n        console.log('HALTING')\r\n      } else {\r\n        this.neuralnet.calculateNetwork(this.board);\r\n        requestAnimationFrame(this.neuralnet.play.bind(this.neuralnet, this.board));\r\n      } // if this.board.gameOver()\r\n    } // if moves.length > 0\r\n  }; // Placement#animate()\r\n}\r\n\r\nPlacement.Node = Node;\r\n\r\nmodule.exports = Placement;\r\n\n\n//# sourceURL=webpack://tetristic/./src/placement.js?");

/***/ }),

/***/ "./src/placement/move.js":
/*!*******************************!*\
  !*** ./src/placement/move.js ***!
  \*******************************/
/***/ ((module) => {

eval("/* tetristic/src/placement/move.js\r\n *\r\n */\r\n\r\nconst Move = {\r\n  ROOT: function MoveRoot(board) {\r\n    return true; // do nothing\r\n  }, // ROOT()\r\n\r\n  UP: function MoveUp(board) {\r\n    while (!board.active.canDecompose()) {\r\n      board.active.translate(0, -1); // repeat move down\r\n    };\r\n    return false; // always stop after a hard drop\r\n  }, // UP()\r\n\r\n  DOWN: function MoveDown(board) {\r\n    return board.active.translate(0, -1); // move down once\r\n  }, // DOWN()\r\n\r\n  LEFT: function MoveLeft(board) {\r\n    return board.active.translate(-1, 0); // move left once\r\n  }, // LEFT()\r\n\r\n  RIGHT: function MoveRight(board) {\r\n    return board.active.translate(1, 0); // move right once\r\n  }, // RIGHT()\r\n\r\n  CW: function MoveCW(board) {\r\n    return board.active.rotateCW(); // move CW once\r\n  }, // CW()\r\n\r\n  CCW: function MoveCCW(board) {\r\n    return board.active.rotateCCW(); // move CCW once\r\n  }, // CCW()\r\n\r\n  getNextMoves: function MoveGetNextMoves(moves) {\r\n    let lastMove = moves.slice(-1)[0];\r\n    let children = [];\r\n    switch (lastMove) {\r\n      case Move.UP:\r\n        // no legal moves\r\n      break;\r\n      // any move is legal at the start, or after a down\r\n      case Move.ROOT:\r\n      case Move.DOWN:\r\n        children = [\r\n          Move.UP,\r\n          Move.DOWN,\r\n          Move.LEFT,\r\n          Move.RIGHT,\r\n          Move.CW,\r\n          Move.CCW,\r\n        ];\r\n      break;\r\n      // should not go RIGHT immediently after a LEFT\r\n      case Move.LEFT:\r\n        children = [\r\n          Move.UP,\r\n          Move.DOWN,\r\n          Move.LEFT,\r\n          Move.CW,\r\n          Move.CCW,\r\n        ];\r\n      break;\r\n      // should not go LEFT immediently after a RIGHT\r\n      case Move.RIGHT:\r\n        children = [\r\n          Move.UP,\r\n          Move.DOWN,\r\n          Move.RIGHT,\r\n          Move.CW,\r\n          Move.CCW,\r\n        ];\r\n      break;\r\n      // should not go CCW immediently after a CW\r\n      // should not go CW four times in a row\r\n      case Move.CW:\r\n        children = [\r\n          Move.UP,\r\n          Move.DOWN,\r\n          Move.LEFT,\r\n          Move.RIGHT,\r\n        ];\r\n        if (moves.slice(-3) !== [Move.CW, Move.CW, Move.CW]) {\r\n          children.push(Move.CW);\r\n        }\r\n      break;\r\n      // should not go CW immediently after a CCW\r\n      // should not go CCW four times in a row\r\n      case Move.CCW:\r\n        children = [\r\n          Move.UP,\r\n          Move.DOWN,\r\n          Move.LEFT,\r\n          Move.RIGHT,\r\n        ];\r\n        if (moves.slice(-3) !== [Move.CCW, Move.CCW, Move.CCW]) {\r\n          children.push(Move.CCW);\r\n        }\r\n      break;\r\n      default:\r\n        console.warn('Cannot getNextMoves for move:', lastMove);\r\n    } // switch lastMove\r\n    return children;\r\n  }, // getNextMoves()\r\n}; // const Move\r\n\r\nmodule.exports = Move;\r\n\n\n//# sourceURL=webpack://tetristic/./src/placement/move.js?");

/***/ }),

/***/ "./src/placement/node.js":
/*!*******************************!*\
  !*** ./src/placement/node.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* tetristic/src/placement/node.js\r\n *\r\n */\r\nconst Move = __webpack_require__(/*! ./move.js */ \"./src/placement/move.js\");\r\nconst State = __webpack_require__(/*! ./state.js */ \"./src/placement/state.js\");\r\n\r\nclass Node {\r\n  constructor(parent, move, board=null) {\r\n    this.parent = parent;\r\n    this.board  = (board && board.clone()) || parent.board.clone();\r\n    this.state  = State.NEW;\r\n    this.best   = { moves: [], score: Number.NEGATIVE_INFINITY };\r\n    this.moves  = (parent ? Array.from(parent.moves) : new Array());\r\n    this.moves.push(move);\r\n  } // Node.constructor()\r\n\r\n  createChildNodes() {\r\n    this.children = new Array();\r\n    for (let child of Move.getNextMoves(this.moves)) {\r\n      this.children.push( new Node(this, child) );\r\n    } // for child of Move.getNextMoves()\r\n    return this.children;\r\n  } // Node#createChildNodes()\r\n\r\n  explore(neuralnet) {\r\n    let queue        = [this];\r\n    let fastestRoute = {};\r\n    let attempt      = 1_000;\r\n    this.maxQueue    = 1;\r\n    this.placed      = 0;\r\n    while (queue.length > 0) {\r\n      this.maxQueue = Math.max(this.maxQueue, queue.length);\r\n      let next = queue.shift();\r\n      next.createChildNodes();\r\n      switch (next.test(fastestRoute)) {\r\n        case State.VALID: // keep searching\r\n          queue.push(...next.children);\r\n        break;\r\n        case State.PLACED:\r\n          this.placed++;\r\n          neuralnet.calculateNetwork(next.board);\r\n          next.best.moves = next.moves;\r\n          next.best.score = neuralnet.values[neuralnet.values.length - 1][0];\r\n          next.better(this); // replace this.best if better\r\n        break;\r\n        case State.SLOW:\r\n        case State.INVALID:\r\n        break; // do nothing, not valid\r\n        default:\r\n          console.warn('Cannot handle Placement.Node State:', next.state);\r\n      } // switch next.test()\r\n    } // while queue.length\r\n    console.info(this);\r\n    console.info(this.maxQueue, queue.length, this.placed);\r\n    return this.best;\r\n  } // Node#explore()\r\n\r\n  better(parent = null) {\r\n    parent = parent || this.parent;\r\n    if (this.best.score > parent.best.score) {\r\n      parent.best.score = this.best.score;\r\n      parent.best.moves = this.best.moves;\r\n      return true;\r\n    } else if (\r\n      (this.best.score === parent.best.score) &&\r\n      (this.best.moves.length < parent.best.moves.length)\r\n    ) {\r\n      parent.best.moves = this.best.moves;\r\n      return true;\r\n    }\r\n    return false;\r\n  } // Node#better()\r\n\r\n  test(fastestRoute) {\r\n    for (let move of this.moves) {\r\n      if (move(this.board)) {\r\n        this.state = State.VALID;\r\n        let fastestPrevious = fastestRoute[JSON.stringify(this.board.active)];\r\n        //console.debug(fastestRoute, fastestPrevious);\r\n        if (fastestPrevious && fastestPrevious.moves.length <= this.moves.length) {\r\n          this.state = State.SLOW;\r\n        } else {\r\n          fastestRoute[JSON.stringify(this.board.active)] = fastestPrevious || { state: State.SLOW };\r\n          fastestRoute[JSON.stringify(this.board.active)].state = State.SLOW;\r\n          fastestRoute[JSON.stringify(this.board.active)] = this;\r\n        }\r\n      } else if (this.board.active.canDecompose()) {\r\n        this.state = State.PLACED;\r\n      } else {\r\n        this.state = State.INVALID;\r\n      } // if can move\r\n    } // for move of this.moves\r\n    return this.state;\r\n  } // Node#test()\r\n} // class Node\r\n\r\nNode.Root = function PlacementNodeRoot(board, neuralnet) {\r\n  return new Node(null, Move.ROOT, board);\r\n}; // Node.Root()\r\n\r\nNode.Move  = Move;\r\nNode.State = State;\r\n\r\nmodule.exports = Node;\r\n\n\n//# sourceURL=webpack://tetristic/./src/placement/node.js?");

/***/ }),

/***/ "./src/placement/state.js":
/*!********************************!*\
  !*** ./src/placement/state.js ***!
  \********************************/
/***/ ((module) => {

eval("/* tetristic/src/placement/state.js\r\n *\r\n */\r\n\r\nconst State = {\r\n  NEW:     \"NEW\",\r\n  VALID:   \"VALID\",\r\n  SLOW:    \"SLOW\",\r\n  INVALID: \"INVALID\",\r\n  PLACED:  \"PLACED\",\r\n};\r\n\r\nmodule.exports = State;\r\n\n\n//# sourceURL=webpack://tetristic/./src/placement/state.js?");

/***/ }),

/***/ "./src/tetromino.js":
/*!**************************!*\
  !*** ./src/tetromino.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* tetristic/src/tetromino/index.js\r\n *\r\n */\r\n\r\nconst Tetromino  = __webpack_require__(/*! ./tetromino/index.js */ \"./src/tetromino/index.js\");\r\nTetromino.shapes = __webpack_require__(/*! ./tetromino/shapes.js */ \"./src/tetromino/shapes.js\");\r\n\r\nmodule.exports = Tetromino;\r\n\n\n//# sourceURL=webpack://tetristic/./src/tetromino.js?");

/***/ }),

/***/ "./src/tetromino/index.js":
/*!********************************!*\
  !*** ./src/tetromino/index.js ***!
  \********************************/
/***/ ((module) => {

eval("/* tetristic/src/tetromino/index.js\r\n *\r\n */\r\n\r\nclass Tetromino {\r\n  constructor(\r\n    board,\r\n    name,\r\n    cellArray,\r\n    color = 'rgb(100, 100, 50)',\r\n    origin = { x: Math.floor(board.width/2), y: board.height-2 }\r\n  ) {\r\n    this.board     = board;\r\n    this.name      = name;\r\n    this.cellArray = cellArray; //Array.from(cellArray, function(cell) { Object.assign({}, cell) });\r\n    this.color     = color;\r\n    this.origin    = Object.assign({}, origin);\r\n    this.orient    = 0;\r\n  } // Tetromino.constructor()\r\n\r\n  clone(\r\n    board = null,\r\n    origin = null\r\n  ) {\r\n    board  = board  || this.board;\r\n    origin = origin || this.origin;\r\n    let newTetromino = new Tetromino(board, this.name, this.cellArray, this.color, origin);\r\n    newTetromino.orient = this.orient;\r\n    return newTetromino;\r\n  } // Tetromino#clone()\r\n\r\n  toJSON(key) {\r\n    // NOTE: I may regret this later\r\n    // this is a hacky way of getting past the self-reference from this.board.active...\r\n    return JSON.stringify({ origin: this.origin, orient: this.orient });\r\n  } // Tetromino#toJSON()\r\n\r\n  cells(\r\n    x = this.origin.x,\r\n    y = this.origin.y\r\n  ) {\r\n    let cells = new Array();\r\n    for (let cell of this.cellArray) {\r\n      cells.push(\r\n        {\r\n          x: cell.x + x, // column\r\n          y: cell.y + y, // row\r\n        }\r\n      ); // cell.push\r\n    } // for cell of this.cellArray\r\n    return cells;\r\n  } // Tetromino#cells()\r\n\r\n  render(\r\n    x = this.origin.x,\r\n    y = this.origin.y,\r\n  ) {\r\n    for (let cell of this.cells(x, y)) {\r\n      this.board.screen.fillStyle = this.color;\r\n      this.board.screen.fillRect(\r\n        (cell.x * this.board.scale) + 1, // x\r\n        (cell.y * this.board.scale * -1) - 1, // y\r\n        this.board.scale - 2, // w\r\n        (this.board.scale - 2) * -1, // h\r\n      ); // fillRect\r\n    } // for cell of this.cells()\r\n  } // Tetromino#render()\r\n\r\n  translate(\r\n    dx=0,\r\n    dy=0\r\n  ) {\r\n    // check for validity\r\n    for (let cell of this.cells()) {\r\n      let x = cell.x + dx; // column\r\n      let y = cell.y + dy; // row\r\n      if (this.isValidCell(x, y) === false) {\r\n        return false;\r\n      } // if this.isValidCell()\r\n    } // for cell of this.cells()\r\n    this.origin.x += dx;\r\n    this.origin.y += dy;\r\n    return this; // chainable\r\n  } // Tetromino#translate()\r\n\r\n  rotateCW() {\r\n    let rotatedCells = new Array();\r\n    for (let cell of this.cellArray) {\r\n      let x = this.origin.x + cell.y;\r\n      let y = this.origin.y - cell.x;\r\n      if (this.isValidCell(x, y) === false) {\r\n        return false;\r\n      } else {\r\n        rotatedCells.push(\r\n          {\r\n            x: cell.y,\r\n            y: cell.x * -1,\r\n          }\r\n        ); // rotatedCells.push()\r\n      } // if this.isValidCell()\r\n    } // for cell of this.cellArray\r\n    this.cellArray = rotatedCells;\r\n    this.orient = (this.orient + 1) % 4;\r\n    return this; // chainable\r\n  } // Tetromino#rotateCW()\r\n\r\n  rotateCCW() {\r\n    let rotatedCells = new Array();\r\n    for (let cell of this.cellArray) {\r\n      let x = this.origin.x - cell.y;\r\n      let y = this.origin.y + cell.x;\r\n      if (this.isValidCell(x, y) === false) {\r\n        return false;\r\n      } else {\r\n        rotatedCells.push(\r\n          {\r\n            x: cell.y * -1,\r\n            y: cell.x,\r\n          }\r\n        ); // rotatedCells.push()\r\n      } // if this.isValidCell()\r\n    } // for cell of this.cellArray\r\n    this.cellArray = rotatedCells;\r\n    this.orient = (this.orient + 3) % 4;\r\n    return this; // chainable\r\n  } // Tetromino#rotateCCW()\r\n\r\n  isValidCell(x, y) {\r\n    if ((x >= this.board.width) || (x < 0)) {\r\n      return false; // out of bounds\r\n    } else if ((y >= this.board.height) || (y < 0)) {\r\n      return false; // out of bounds\r\n    } else if (this.board.getCell(x, y) !== null) {\r\n      return false; // already occupied\r\n    } else {\r\n      return true; // legal\r\n    }\r\n  } // Tetromino#isValidCell()\r\n\r\n  canDecompose() {\r\n    for (let cell of this.cells()) {\r\n      if ((cell.y === 0)) {\r\n        return true; // resting on floor\r\n      } else if (this.board.getCell(cell.x, cell.y-1)) {\r\n        return true; // resting on another piece\r\n      } // if cell is resting\r\n    } // for cell of this.cells()\r\n    return false;\r\n  } // Tetromino#canDecompose()\r\n\r\n  decompose() {\r\n    for (let cell of this.cells()) {\r\n      this.board.cells[cell.x][cell.y] = new Tetromino(\r\n        this.board,\r\n        this.name,\r\n        [\r\n          {x: 0, y: 0},\r\n        ],\r\n        this.color,\r\n        {x: cell.x, y: cell.y}\r\n      ); // new Tetromino\r\n    } // for cell of this.cells()\r\n  } // Tetromino#decompose()\r\n} // class Tetromino\r\n\r\nmodule.exports = Tetromino;\r\n\n\n//# sourceURL=webpack://tetristic/./src/tetromino/index.js?");

/***/ }),

/***/ "./src/tetromino/shapes.js":
/*!*********************************!*\
  !*** ./src/tetromino/shapes.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Tetromino = __webpack_require__(/*! ./index.js */ \"./src/tetromino/index.js\");\r\n\r\nconst Shapes = {\r\n  I: function shapesI(board) {\r\n    return new Tetromino(\r\n      board,\r\n      'I',\r\n      [\r\n        {x: -2, y:  1},\r\n        {x: -1, y:  1},\r\n        {x:  0, y:  1},\r\n        {x:  1, y:  1},\r\n      ],\r\n      'Turquoise'\r\n    ); // return new Tetromino()\r\n  }, // Shapes.I()\r\n  J: function shapesJ(board) {\r\n    return new Tetromino(\r\n      board,\r\n      'J',\r\n      [\r\n        {x: -1, y:  1},\r\n        {x: -1, y:  0},\r\n        {x:  0, y:  0},\r\n        {x:  1, y:  0},\r\n      ],\r\n      'RoyalBlue'\r\n    ); // return new Tetromino()\r\n  }, // Shapes.J()\r\n  L: function shapesL(board) {\r\n    return new Tetromino(\r\n      board,\r\n      'L',\r\n      [\r\n        {x:  1, y:  1},\r\n        {x:  1, y:  0},\r\n        {x:  0, y:  0},\r\n        {x: -1, y:  0},\r\n      ],\r\n      'Tomato'\r\n    ); // return new Tetromino()\r\n  }, // Shapes.L()\r\n  O: function shapesO(board) {\r\n    return new Tetromino(\r\n      board,\r\n      'O',\r\n      [\r\n        {x: -1, y:  1},\r\n        {x:  0, y:  1},\r\n        {x: -1, y:  0},\r\n        {x:  0, y:  0},\r\n      ],\r\n      'Gold'\r\n    ); // return new Tetromino()\r\n  }, // Shapes.O()\r\n  S: function shapesS(board) {\r\n    return new Tetromino(\r\n      board,\r\n      'S',\r\n      [\r\n        {x:  1, y:  1},\r\n        {x:  0, y:  1},\r\n        {x:  0, y:  0},\r\n        {x: -1, y:  0},\r\n      ],\r\n      'SeaGreen'\r\n    ); // return new Tetromino()\r\n  }, // Shapes.S()\r\n  T: function shapesT(board) {\r\n    return new Tetromino(\r\n      board,\r\n      'T',\r\n      [\r\n        {x:  0, y:  0},\r\n        {x:  0, y:  1},\r\n        {x:  1, y:  0},\r\n        {x: -1, y:  0},\r\n      ],\r\n      'HotPink'\r\n    ); // return new Tetromino()\r\n  }, // Shapes.T()\r\n  Z: function shapesZ(board) {\r\n    return new Tetromino(\r\n      board,\r\n      'Z',\r\n      [\r\n        {x:  1, y:  0},\r\n        {x:  0, y:  0},\r\n        {x:  0, y:  1},\r\n        {x: -1, y:  1},\r\n      ],\r\n      'DarkRed'\r\n    ); // return new Tetromino()\r\n  }, // Shapes.Z()\r\n  random: function shapesRandom(\r\n    board,\r\n    last = { name: null },\r\n  ) {\r\n    // direct access would be faster,\r\n    // at the expense of needing to clone the selected\r\n    // TODO: allow direct access to the original templates\r\n    // to speed up this function if needed?\r\n    let array = [\r\n      Shapes.I(board),\r\n      Shapes.J(board),\r\n      Shapes.L(board),\r\n      Shapes.O(board),\r\n      Shapes.S(board),\r\n      Shapes.T(board),\r\n      Shapes.Z(board),\r\n    ];\r\n    let random = Math.floor(Math.random() * 7);\r\n    // don't force it not to repeat, just roll again as a nudge\r\n    // this reduces the chance of a repeat from 1/7 to 1/49\r\n    if (last.name === array[random].name) {\r\n      random = Math.floor(Math.random() * 7);\r\n    }\r\n    return array[random];\r\n  } // Shapes.random()\r\n}; // const Shapes\r\n\r\nmodule.exports = Shapes;\r\n\n\n//# sourceURL=webpack://tetristic/./src/tetromino/shapes.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;