/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/board/index.js":
/*!****************************!*\
  !*** ./src/board/index.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Placement = __webpack_require__(/*! ./placement.js */ \"./src/board/placement.js\");\r\nconst Tetromino = __webpack_require__(/*! ../tetromino/index.js */ \"./src/tetromino/index.js\");\r\n\r\nclass Board {\r\n  constructor(canvasObj, scale=20) {\r\n    let rowCount = this.rowCount = 20;\r\n    let colCount = this.colCount = 10;\r\n    this.context = canvasObj.getContext('2d');\r\n    this.scale   = scale;\r\n    this.clears  = 0;\r\n    // generate an empty board of cells\r\n    this.cells = Array.from( new Array(rowCount), function() {\r\n      return Array.from( new Array(colCount), function() { return null; });\r\n    });\r\n    // generate the upcoming pieces\r\n    this.activeTetromino = Tetromino.shape.getRandom();\r\n    this.nextTetromino   = Tetromino.shape.getRandom(this.activeTetromino);\r\n    // render\r\n    this.renderBackground();\r\n    this.renderForeground();\r\n    this.renderNext();\r\n  } // constructor()\r\n\r\n  clone() {\r\n    let retval = new Board(this.context.canvas, this.scale);\r\n    let rowCount = retval.rowCount;\r\n    let colCount = retval.colCount;\r\n    let _orig    = this;\r\n    retval.cells = Array.from( new Array(rowCount), function(row, rowIndex) {\r\n      return Array.from( _orig.cells[rowIndex], function(cell) { return cell ? cell.clone() : null; });\r\n    });\r\n    retval.activeTetromino = this.activeTetromino.clone();\r\n    retval.nextTetromino   = this.nextTetromino.clone();\r\n    return retval;\r\n  } // clone()\r\n\r\n  renderBackground(scale=this.scale, xLow=0, xHigh=10, yLow=0, yHigh=20) {\r\n    this.context.fillStyle = 'rgb(150, 150, 150)';\r\n    for (let _row = yLow; _row < yHigh; _row++) {\r\n      for (let _col = xLow; _col < xHigh; _col++) {\r\n        let _y = _row * scale;\r\n        let _x = _col * scale;\r\n        this.context.fillRect( _x+1, _y+1, scale-2, scale-2 );\r\n      } // for _col\r\n    } // for _row\r\n  } // renderBackground()\r\n\r\n  renderForeground(scale=this.scale, xLow=0, xHigh=10, yLow=0, yHigh=20) {\r\n    for (let _row = yLow; _row < yHigh; _row++) {\r\n      for (let _col = xLow; _col < xHigh; _col++) {\r\n        let _cell = this.cells[_row][_col];\r\n        if (_cell !== null) {\r\n          _cell.render(this);\r\n        }\r\n      } // for _col\r\n    } // for _row\r\n    this.activeTetromino.render(this);\r\n  } // renderForeground()\r\n\r\n  renderNext(scale=this.scale) {\r\n    this.context.font         = this.scale + 'px monospace';\r\n    this.context.textBaseline = 'bottom';\r\n    this.context.strokeStyle  = 'rgb(150, 150, 150)';\r\n    this.renderBackground(scale, 11, 15, 3, 7);\r\n    this.context.fillText(\"NEXT\", scale*11, scale*3);\r\n    this.nextTetromino.render(this, 13, 5);\r\n    this.context.fillStyle = 'rgb(255, 255, 255)';\r\n    this.context.fillRect(scale*11, scale*9, scale*4, scale*1);\r\n    this.context.fillStyle = 'rgb(150, 150, 150)';\r\n    this.context.fillText(\"CLEARED:\", scale*11, scale*9);\r\n    this.context.fillText(this.clears, scale*11, scale*10);\r\n  } // renderNext()\r\n\r\n  play() {\r\n    document.onkeydown = this.onKeyDown.bind(this);\r\n    requestAnimationFrame(this.update.bind(this, true));\r\n  } // play()\r\n\r\n  onKeyDown(event) {\r\n    switch (event.key) {\r\n      case 'q': // CCW\r\n        this.activeTetromino.rotateCCW(this);\r\n      break;\r\n      case 'e': // CW\r\n        this.activeTetromino.rotateCW(this);\r\n      break;\r\n      case 'a':\r\n      case 'ArrowLeft': // left\r\n        this.activeTetromino.translate(this,  -1, 0); // dx, dy\r\n      break;\r\n      case 'w':\r\n      case 'ArrowUp': // up\r\n        while (!this.activeTetromino.testForLatch(this)) {\r\n          this.activeTetromino.translate(this, 0, 1); // dx, dy\r\n        }\r\n        this.activeTetromino.decompose(this);\r\n        this.activeTetromino = null;\r\n      break;\r\n      case 'd':\r\n      case 'ArrowRight': // right\r\n        this.activeTetromino.translate(this,   1, 0); // dx, dy\r\n      break;\r\n      case 's':\r\n      case 'ArrowDown': // down\r\n        // if this piece cannot move downward (latched)\r\n        if (!this.activeTetromino.translate(this,   0, 1)) {\r\n          // then decompose it and prepare a new one\r\n          this.activeTetromino.decompose(this);\r\n          this.activeTetromino = null;\r\n        }\r\n      break;\r\n      default:\r\n        console.log(`Pressed key: ${event.key}`);\r\n    }\r\n  } // onKeyDown()\r\n\r\n  clearLines() {\r\n    for (let _row = this.rowCount - 1; _row > 0; _row--) {\r\n      while (this.cells[_row].every(function(_cell) { return _cell !== null; })) {\r\n        // shift each row above downward\r\n        this.clears++;\r\n        for (let _rowAbove = _row; _rowAbove > 0; _rowAbove--) {\r\n          // clear this row\r\n          this.cells[_rowAbove] = Array.from(new Array(this.colCount), function() { return null; })\r\n          // translate the cells down\r\n          for (let _cell of this.cells[_rowAbove-1]) {\r\n            if (_cell !== null) {\r\n              _cell.translate(this, 0, 1);\r\n            }\r\n          }\r\n          // replace the row with the contents of the one above\r\n          this.cells[_rowAbove] = Array.from(this.cells[_rowAbove - 1]);\r\n        }\r\n      } // if _row is full\r\n    } // for _row\r\n  } // clearLines()\r\n\r\n  keepPlaying() {\r\n    return (\r\n      this.cells[0].every(function(_cell) { return _cell === null}) &&\r\n      this.cells[1].every(function(_cell) { return _cell === null})\r\n    );\r\n  } // keepPlaying()\r\n\r\n  update(animate=false) {\r\n    // refill the next tetromino, if needed\r\n    if (this.activeTetromino === null) {\r\n      this.activeTetromino = this.nextTetromino;\r\n      this.nextTetromino   = Tetromino.shape.getRandom();\r\n    }\r\n    this.clearLines();\r\n    this.renderBackground();\r\n    this.renderForeground();\r\n    this.renderNext();\r\n    if (animate && this.keepPlaying()) {\r\n      requestAnimationFrame(this.update.bind(this, animate));\r\n    }\r\n  } // update()\r\n} // class Board\r\n\r\nBoard.Placement = Placement;\r\n\r\nmodule.exports = Board;\r\n\n\n//# sourceURL=webpack://tetristic/./src/board/index.js?");

/***/ }),

/***/ "./src/board/placement.js":
/*!********************************!*\
  !*** ./src/board/placement.js ***!
  \********************************/
/***/ ((module) => {

eval("const PlacementMovement = {\r\n  ROOT: function placementMovementRoot(board) {\r\n    return true;\r\n  }, // ROOT\r\n  UP: function placementMovementUp(board) {\r\n    while (!board.activeTetromino.testForLatch(board)) {\r\n      board.activeTetromino.translate(board, 0, 1);\r\n    }\r\n    return true; // this is always legal\r\n  }, // UP\r\n  DOWN: function placementMovementDown(board) {\r\n    return board.activeTetromino.translate(board,  0, 1);\r\n  }, // DOWN\r\n  LEFT: function placementMovementLeft(board) {\r\n    return board.activeTetromino.translate(board, -1, 0);\r\n  }, // LEFT\r\n  RIGHT: function placementMovementRight(board) {\r\n    return board.activeTetromino.translate(board,  1, 0);\r\n  }, // RIGHT\r\n  CW: function placementMovementCW(board) {\r\n    return board.activeTetromino.rotateCW(board);\r\n  }, // CW\r\n  CCW: function placementMovementCCW(board) {\r\n    return board.activeTetromino.rotateCCW(board);\r\n  }, // CCW\r\n} // const PlacementMovement\r\n\r\nconst PlacementNodeState = {\r\n  NEW: \"NEW\",\r\n  VALID: \"VALID\",\r\n  INVALID: \"INVALID\",\r\n  KNOWN: \"KNOWN\",\r\n  PLACED: \"PLACED\",\r\n} // const PlacementNodeState\r\n\r\nclass PlacementNode {\r\n  constructor(parent, move, knownPositions, board=null) {\r\n    this.best  = {moves: [], score: Number.NEGATIVE_INFINITY};\r\n    this.state = PlacementNodeState.NEW;\r\n    // keep track of all moves made so far\r\n    this.moves = new Array();\r\n    if (parent !== null) {\r\n      this.moves = Array.from(parent.moves);\r\n      this.board = parent.board.clone();\r\n    } else {\r\n      this.board = board.clone();\r\n    } // if parent\r\n    this.moves.push(move);\r\n    // validate this movement\r\n    this.children = new Array();\r\n    if (move(this.board)) {\r\n      if (\r\n        (knownPositions[JSON.stringify(this.board.activeTetromino)]) &&\r\n        (knownPositions[JSON.stringify(this.board.activeTetromino)] <= this.moves.length)\r\n      ) {\r\n        this.state = PlacementNodeState.KNOWN;\r\n      } else {\r\n        this.state = PlacementNodeState.VALID;\r\n        knownPositions[JSON.stringify(this.board.activeTetromino)] = this.moves.length;\r\n        this.createChildPlacementNodes(move, knownPositions);\r\n      }\r\n    } else {\r\n      this.state = PlacementNodeState.INVALID;\r\n      if (this.board.activeTetromino.testForLatch(this.board)) {\r\n        this.state = PlacementNodeState.PLACED;\r\n        console.info('PlacementNode constructor()', this);\r\n      }\r\n    } // if move board\r\n  } // constructor()\r\n\r\n  createChildPlacementNodes(lastMove, knownPositions) {\r\n    switch (lastMove) {\r\n      case PlacementMovement.UP:\r\n        // no legal moves after an UP, halt\r\n      break;\r\n      case PlacementMovement.ROOT:\r\n      case PlacementMovement.DOWN:\r\n        // any move can be legal after a DOWN\r\n        this.children = [\r\n          new PlacementNode(this, PlacementMovement.UP, knownPositions),\r\n          new PlacementNode(this, PlacementMovement.DOWN, knownPositions),\r\n          new PlacementNode(this, PlacementMovement.LEFT, knownPositions),\r\n          new PlacementNode(this, PlacementMovement.RIGHT, knownPositions),\r\n          new PlacementNode(this, PlacementMovement.CW, knownPositions),\r\n          new PlacementNode(this, PlacementMovement.CCW, knownPositions),\r\n        ];\r\n      break;\r\n      case PlacementMovement.LEFT:\r\n        // should not go RIGHT immediently after a LEFT\r\n        this.children = [\r\n          new PlacementNode(this, PlacementMovement.UP, knownPositions),\r\n          new PlacementNode(this, PlacementMovement.DOWN, knownPositions),\r\n          new PlacementNode(this, PlacementMovement.LEFT, knownPositions),\r\n          new PlacementNode(this, PlacementMovement.CW, knownPositions),\r\n          new PlacementNode(this, PlacementMovement.CCW, knownPositions),\r\n        ];\r\n      break;\r\n      case PlacementMovement.RIGHT:\r\n        // should not go LEFT immediently after a RIGHT\r\n        this.children = [\r\n          new PlacementNode(this, PlacementMovement.UP, knownPositions),\r\n          new PlacementNode(this, PlacementMovement.DOWN, knownPositions),\r\n          new PlacementNode(this, PlacementMovement.RIGHT, knownPositions),\r\n          new PlacementNode(this, PlacementMovement.CW, knownPositions),\r\n          new PlacementNode(this, PlacementMovement.CCW, knownPositions),\r\n        ];\r\n      break;\r\n      case PlacementMovement.CW:\r\n        // should not go CCW immediently after a CW\r\n        // should not go CW four times in a row\r\n        this.children = [\r\n          new PlacementNode(this, PlacementMovement.UP, knownPositions),\r\n          new PlacementNode(this, PlacementMovement.DOWN, knownPositions),\r\n          new PlacementNode(this, PlacementMovement.LEFT, knownPositions),\r\n          new PlacementNode(this, PlacementMovement.RIGHT, knownPositions),\r\n        ];\r\n        // check last three moves\r\n        if (this.moves.slice(-3) !== [PlacementMovement.CW, PlacementMovement.CW, PlacementMovement.CW]) {\r\n          this.children.push(new PlacementNode(this, PlacementMovement.CW, knownPositions));\r\n        }\r\n      break;\r\n      case PlacementMovement.CCW:\r\n        // should not go CW immediently after a CCW\r\n        // should not go CCW four times in a row\r\n        this.children = [\r\n          new PlacementNode(this, PlacementMovement.UP, knownPositions),\r\n          new PlacementNode(this, PlacementMovement.DOWN, knownPositions),\r\n          new PlacementNode(this, PlacementMovement.LEFT, knownPositions),\r\n          new PlacementNode(this, PlacementMovement.RIGHT, knownPositions),\r\n        ];\r\n        // check last three moves\r\n        if (this.moves.slice(-3) !== [PlacementMovement.CCW, PlacementMovement.CCW, PlacementMovement.CCW]) {\r\n          this.children.push(new PlacementNode(this, PlacementMovement.CCW, knownPositions));\r\n        }\r\n      break;\r\n    }\r\n  } // createChildPlacementNodes()\r\n\r\n  findBest(network) {\r\n    if (this.state === PlacementNodeState.PLACED) {\r\n      network.calculateNetwork(this.board);\r\n      this.best.moves = this.moves;\r\n      this.best.score = network.values[network.values.length - 1][0];\r\n    } else {\r\n      for (let child of this.children) {\r\n        child.findBest(network);\r\n        // take the higher score\r\n        if (child.best.score > this.best.score) {\r\n          this.best.score = child.best.score;\r\n          this.best.moves = child.best.moves;\r\n        // if they're equal, take the faster route\r\n        } else if (\r\n          (child.best.score === this.best.score) &&\r\n          (child.best.moves.length < this.best.moves.length)) {\r\n            this.best.score = child.best.score;\r\n            this.best.moves = child.best.moves;\r\n        }\r\n      } // for child of this.children\r\n    } // if state === PLACED\r\n  } // findBest()\r\n} // class PlacementNode\r\n\r\nclass Placement {\r\n  constructor(board, network) {\r\n    this.board   = board;\r\n    this.network = network;\r\n    this.knownPositions = {};\r\n  } // constructor()\r\n\r\n  /* The logic to this one is kinda funky, so I'll lay it out\r\n   * ahead of time. There are only six valid moves you can\r\n   * make with a Tetromino:\r\n   * 1) MOVE DOWN (no restrictions, irreversable)\r\n   * 2) MOVE LEFT (cannot immediently follow/be followed by MOVE RIGHT)\r\n   * 3) MOVE RIGHT (cannot immediently follow/be followed by MOVE LEFT)\r\n   * 4) ROTATE CW (cannot perform four times in a row;\r\n   *      cannot immediently follow/be followed by ROTATE CCW)\r\n   * 5) ROTATE CCW (cannot perform four times in a row;\r\n   *      cannot immediently follow/be followed by ROTATE CW)\r\n   * 6) MOVE UP (secret quit-out early move, irreversable)\r\n   *\r\n   * With this in mind, we can construct a search tree, working\r\n   * down the tree until all leaf nodes have been verified to have\r\n   * no further valid moves afterwards. We can feed all the leaf states\r\n   * into the heuristics to find the best placement for our current piece.\r\n   * In case of a tie, we can take the leaf with the shortest path.\r\n   */\r\n  findBest() {\r\n    console.log(`Finding Best Move for ${this.board.activeTetromino.name}...`);\r\n    this.root = new PlacementNode(null, PlacementMovement.ROOT, this.knownPositions, this.board);\r\n    this.root.findBest(this.network);\r\n    console.log('Best Move:', this.root.best);\r\n    let moves = Array.from(this.root.best.moves);\r\n    this.animate(moves);\r\n  } // findBest()\r\n\r\n  animate(moves) {\r\n    let move = moves.shift();\r\n    move(this.board);\r\n    this.board.update();\r\n    if (moves.length > 0) {\r\n      requestAnimationFrame(this.animate.bind(this, moves));\r\n    } else {\r\n      this.board.activeTetromino.decompose(this.board);\r\n      this.board.activeTetromino = null;\r\n      this.board.update();\r\n      requestAnimationFrame(this.network.play.bind(this.network, this.board));\r\n    }\r\n  } // animate()\r\n\r\n} // class Placement\r\n\r\nmodule.exports = Placement;\r\n\n\n//# sourceURL=webpack://tetristic/./src/board/placement.js?");

/***/ }),

/***/ "./src/heuristic/index.js":
/*!********************************!*\
  !*** ./src/heuristic/index.js ***!
  \********************************/
/***/ ((module) => {

eval("// tetristic/heuristic/index.js\r\n\r\n// All the heuristics here are normalized.\r\n// That is to say, they are bound to a range of either 0~1 or -1~1\r\n// depending on what is appropriate for our use case.\r\n// I do not want my factors and biases spiraling out of control here,\r\n// so we are normalizing the input of all heuristics.\r\n\r\nconst Heuristic = {\r\n  sigmoid: function heuristicSigmoid(x) {\r\n    return (2 / (1 + Math.exp(x * -1)) - 1)\r\n  }, // sigmoid()\r\n\r\n  maxHeight: function heuristicMaxHeight(board) {\r\n    // start at the bottom, counting upward\r\n    // this will keep track of the highest populated row,\r\n    // where 0 is the ceiling and 20 is empty\r\n    let retval = 0;\r\n    for (var _row = board.rowCount - 1; _row >= 0; _row--) {\r\n      for (let _cell of board.cells[_row]) {\r\n        if (_cell !== null) {\r\n          retval = board.rowCount - _row;\r\n        } // if _cell !== null\r\n      } // for _cell\r\n    } // for _row\r\n    // reverse this, then normalize\r\n    // (e.g. row 0 => height 20 => 100% => 1.0)\r\n    retval = retval / board.rowCount;\r\n    return retval;\r\n  }, // maxHeight()\r\n\r\n  sumOfHeight: function heuristicSumOfHeight(board) {\r\n    // start at the bottom, counting upward\r\n    // this will keep track of the highest populated row,\r\n    // where 0 is the ceiling and 20 is empty\r\n    let retval = board.rowCount;\r\n    let cols   = new Array(board.colCount);\r\n    cols.fill(0);\r\n    for (let _row = board.rowCount - 1; _row >= 0; _row--) {\r\n      for (let _col = 0; _col < board.colCount; _col++) {\r\n        if (board.cells[_row][_col] !== null) {\r\n          cols[_col] = board.rowCount - _row;\r\n        }\r\n      } // for _col\r\n    } // for _row\r\n    //\r\n    retval = cols.reduce(function(sum, curr) { return sum + curr }, 0);\r\n    retval = retval / (board.rowCount * board.colCount);\r\n    return retval;\r\n\r\n  }, // sumOfHeight()\r\n\r\n  list: [], // list\r\n}; // Heuristic\r\n\r\nHeuristic.list.push( Heuristic.maxHeight );\r\nHeuristic.list.push( Heuristic.sumOfHeight );\r\n\r\nmodule.exports = Heuristic;\r\n\n\n//# sourceURL=webpack://tetristic/./src/heuristic/index.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("var Tetristic = {};\r\n\r\nTetristic.Board = __webpack_require__(/*! ./board/index.js */ \"./src/board/index.js\");\r\nTetristic.Network = __webpack_require__(/*! ./network/index.js */ \"./src/network/index.js\");\r\n\r\nwindow.onload = function() {\r\n  let board = new Tetristic.Board( document.getElementById('tetristic-board') );\r\n  let network = new Tetristic.Network( document.getElementById('tetristic-network') );\r\n  board.play();\r\n  network.play(board);\r\n};\r\n\n\n//# sourceURL=webpack://tetristic/./src/index.js?");

/***/ }),

/***/ "./src/network/index.js":
/*!******************************!*\
  !*** ./src/network/index.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Heuristic = __webpack_require__(/*! ../heuristic/index.js */ \"./src/heuristic/index.js\");\r\nconst Board = __webpack_require__(/*! ../board/index.js */ \"./src/board/index.js\");\r\n\r\nclass Network {\r\n  constructor(canvasObj=null, depth=null, widths=null, weights=null, biases=null) {\r\n    this.context = canvasObj.getContext('2d');\r\n    this.generate(depth, widths, weights, biases);\r\n    this.render();\r\n  } // constructor()\r\n\r\n  clone() {\r\n    new Network(this.context.canvas, this.depth, this.widths, this.weights, this.biases);\r\n  } // clone()\r\n\r\n  generate(depth, widths, weights, biases) {\r\n    if (depth === null) {\r\n      this.depth = Math.floor(1 + Math.random() * 3); // 1 <=> 3 layers\r\n    } else {\r\n      this.depth = depth;\r\n    }\r\n\r\n    if (widths === null) {\r\n      this.widths = [];\r\n      let _lastLayerWidth = Heuristic.list.length;\r\n      for (let _layer = 0; _layer < this.depth - 1; _layer++) {\r\n        // this forces a layer to be between x0.5 <=> x1.5 the size of the last\r\n        let _newLayerWidth = Math.max( Math.floor( _lastLayerWidth * (0.5 + Math.random()) ), 2);\r\n        this.widths.push(_newLayerWidth);\r\n        _lastLayerWidth = _newLayerWidth;\r\n      } // for _layer\r\n      this.widths.push(1);\r\n    } else {\r\n      this.widths = widths;\r\n    }\r\n\r\n    if (weights === null) {\r\n      this.weights = [];\r\n      let _lastLayerWidth = Heuristic.list.length;\r\n      for (let _layer = 0; _layer < this.depth; _layer++) {\r\n        this.weights.push( new Array() );\r\n        for (let _node = 0; _node < this.widths[_layer]; _node++) {\r\n          this.weights[_layer].push( new Array() );\r\n          for (let _lastNode = 0; _lastNode < _lastLayerWidth; _lastNode++) {\r\n            this.weights[_layer][_node].push( (Math.random() * 2) - 1 ); // -1 <=> 1\r\n          } // for _lastNode\r\n        } // for _node\r\n        _lastLayerWidth = this.widths[_layer];\r\n      } // for _layer\r\n    } else {\r\n      this.weights = weights;\r\n    }\r\n\r\n    if (biases === null) {\r\n      this.biases = [];\r\n      for (let _layer = 0; _layer < this.depth; _layer++) {\r\n        this.biases.push( new Array() );\r\n        for (let _node = 0; _node < this.widths[_layer]; _node++) {\r\n          this.biases[_layer].push( (Math.random() * 2) - 1 ); // -1 <=> 1\r\n        } // for _node\r\n      } // for _layer\r\n    } else {\r\n      this.biases = biases;\r\n    }\r\n\r\n    this.values = new Array();\r\n    // input layer first\r\n    this.values.push( new Array() );\r\n    for (let _input = 0; _input < Heuristic.list.length; _input++) {\r\n      this.values[0].push(0); // value defaults to 0\r\n    } // for _input\r\n    // hidden/output layers\r\n    for (let _layer = 0; _layer < this.depth; _layer++) {\r\n      this.values.push( new Array() );\r\n      for (let _node = 0; _node < this.widths[_layer]; _node++) {\r\n        this.values[_layer+1].push(0); // value defaults to 0\r\n      } // for _node\r\n    } // for _layer\r\n\r\n    // how wide are the graphics for the neural network allowed to be?\r\n    this.widthScale = Math.floor(\r\n      // canvas width divided by the largest of either\r\n      // the widest point in the neural network or the starting inputs\r\n      this.context.canvas.width / Math.max(...this.widths, Heuristic.list.length)\r\n    );\r\n    // how tall are the graphics for the neural network allowed to be?\r\n    this.heightScale = Math.floor(\r\n      // the input and output layers will always be visible, plus any hidden layers\r\n      this.context.canvas.height / (this.depth + 1)\r\n    );\r\n  } // generate()\r\n\r\n  calculateNetwork(board) {\r\n    for (let _input = 0; _input < Heuristic.list.length; _input++) {\r\n      this.values[0][_input] = Heuristic.list[_input](board);\r\n    } // for _input\r\n    for (let _layer = 0; _layer < this.depth; _layer++) {\r\n      for (let _node = 0; _node < this.widths[_layer]; _node++) {\r\n        let _sum = 0;\r\n        for (let _link = 0; _link < this.weights[_layer][_node].length; _link++) {\r\n          // this.values[_layer] is a bit of a trick...\r\n          // since ONLY values includes the input layer,\r\n          // we are reading the layer BEFORE the active layer\r\n          _sum += this.values[_layer][_link] * this.weights[_layer][_node][_link];\r\n        } // for _link\r\n        _sum += this.biases[_layer][_node];\r\n        this.values[_layer+1][_node] = Heuristic.sigmoid(_sum);\r\n      } // for _node\r\n    } // for _layer\r\n  } // calculateNetwork()\r\n\r\n  render() {\r\n    this.renderLinks();\r\n    this.renderNodes();\r\n  } // render()\r\n\r\n  renderNodes() {\r\n    // the inputs\r\n    for (let _input = 0; _input < Heuristic.list.length; _input++) {\r\n      this.renderNode(0, _input);\r\n    } // for _input\r\n    // the hidden/output layers\r\n    for (let _layer = 0; _layer < this.depth; _layer++) {\r\n      for (let _node = 0; _node < this.widths[_layer]; _node++) {\r\n        this.renderNode(_layer+1, _node);\r\n      } // for _node\r\n    } // for _layer\r\n  } // renderNodes()\r\n\r\n  renderNode(layer, node) {\r\n    // precalculate some scaling options\r\n    let scale  = Math.min(this.widthScale, this.heightScale);\r\n    let offset = Math.floor(scale / 4);\r\n    let x     = (node * scale) + offset;\r\n    let y     = (layer * scale) + offset;\r\n    // setup the canvas as we like it\r\n    this.context.font         = '14px monospace';\r\n    this.context.lineWidth    = 2;\r\n    this.context.textAlign    = 'right';\r\n    this.context.textBaseline = 'top';\r\n    this.context.fillStyle    = 'rgb(255, 255, 255)';\r\n    this.context.strokeStyle  = 'rgb(0, 0, 0)';\r\n    // draw the rectangle, then the text on top\r\n    this.context.fillRect(x, y, offset*2, offset*2);\r\n    this.context.strokeRect(x, y, offset*2, offset*2);\r\n    this.context.fillStyle = this.calcColorRedBlackGreen(this.values[layer][node]);\r\n    this.context.fillText(this.values[layer][node].toFixed(3), x + offset*2, y);\r\n  } // renderNode()\r\n\r\n  renderLinks() {\r\n    let scale = Math.min(this.widthScale, this.heightScale);\r\n    let offset = Math.floor(scale / 2);\r\n    for (let _layer = 0; _layer < this.depth; _layer++) {\r\n      for (let _node = 0; _node < this.widths[_layer]; _node++) {\r\n        let _start = {x: _node * scale, y: (_layer + 1) * scale};\r\n        for (let _link = 0; _link < this.weights[_layer][_node].length; _link++) {\r\n          let _end = {x: _link * scale, y: _layer * scale};\r\n          this.context.lineWidth   = 5;\r\n          this.context.strokeStyle = this.calcColorRedBlackGreen(this.weights[_layer][_node][_link]);\r\n          this.context.beginPath();\r\n          this.context.moveTo(_start.x + offset, _start.y + offset);\r\n          this.context.lineTo(_end.x + offset, _end.y + offset);\r\n          this.context.stroke();\r\n        } // for _link\r\n      } // for _node\r\n    } // for _layer\r\n  } // renderLinks()\r\n\r\n  calcColorRedBlackGreen(decimal) {\r\n    let red   = 0;\r\n    let blue  = 0;\r\n    let green = 0;\r\n    if (decimal < 0) { // red/black (based on 'crimson')\r\n      red   = Math.floor(decimal * -220);\r\n      blue  = Math.floor(decimal *  -20);\r\n      green = Math.floor(decimal *  -60);\r\n\r\n    } else { // green/black (based on 'sea green')\r\n      red   = Math.floor(decimal *  20);\r\n      blue  = Math.floor(decimal * 220);\r\n      green = Math.floor(decimal *  60);\r\n    }\r\n    return `rgb(${red},${blue},${green})`;\r\n  } // calcColorRedBlackGreen()\r\n\r\n  calcColorRedWhiteGreen() {} // calcColorRedWhiteGreen()\r\n\r\n  play(board) {\r\n    board.update();\r\n    let placement = new Board.Placement(board, this);\r\n    placement.findBest();\r\n    this.calculateNetwork(board);\r\n    this.render();\r\n  } // play()\r\n} // class Network\r\n\r\nNetwork.heuristic = Heuristic;\r\n\r\nmodule.exports = Network;\r\n\n\n//# sourceURL=webpack://tetristic/./src/network/index.js?");

/***/ }),

/***/ "./src/tetromino/index.js":
/*!********************************!*\
  !*** ./src/tetromino/index.js ***!
  \********************************/
/***/ ((module) => {

eval("const DEFAULT_STARTING_POS = {x: 5, y: 1};\r\n\r\nclass Tetromino {\r\n  constructor(name, cellArray, color='rgb(100, 100, 50)', startingPos=DEFAULT_STARTING_POS) {\r\n    this.name      = name;\r\n    this.origin    = Object.assign({}, startingPos);\r\n    this.cellArray = cellArray;\r\n    this.color     = color;\r\n  } // constructor()\r\n\r\n  clone() {\r\n    return new Tetromino(this.name, this.cellArray, this.color, this.origin);\r\n  } // clone()\r\n\r\n  getCells(x=this.origin.x, y=this.origin.y) {\r\n    let _cells = [];\r\n    for (let _cell of this.cellArray) {\r\n      _cells.push({\r\n        x: _cell.x + x, // column\r\n        y: _cell.y + y, // row\r\n      });\r\n    }\r\n    return _cells;\r\n  } // getCells()\r\n\r\n  render(board, x=this.origin.x, y=this.origin.y) {\r\n    for (let _cell of this.getCells(x, y)) {\r\n      board.context.fillStyle = this.color;\r\n      board.context.fillRect(\r\n        (_cell.x * board.scale) + 1, // x\r\n        (_cell.y * board.scale) + 1, // y\r\n        board.scale - 2, // w\r\n        board.scale - 2  // h\r\n      );\r\n    } // for _cell of getCells()\r\n  } // render()\r\n\r\n  translate(board, dx=0, dy=0) {\r\n    for (let _cell of this.getCells()) {\r\n      if ((_cell.x + dx >= 10) || (_cell.x + dx < 0)) {\r\n        return false;\r\n      } else if ((_cell.y + dy >= 20) || (_cell.y + dy < 0)) {\r\n        return false;\r\n      } else if (board.cells[_cell.y + dy][_cell.x + dx] !== null) {\r\n        return false;\r\n      }\r\n    }\r\n    this.origin.x += dx;\r\n    this.origin.y += dy;\r\n    return true;\r\n  } // translate()\r\n\r\n  testForLatch(board) {\r\n    for (let _cell of this.getCells()) {\r\n      // if the cell below us is occupied\r\n      if ((_cell.y === 19) || board.cells[_cell.y + 1][_cell.x] !== null) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  } // testForLatch()\r\n\r\n  rotateCW(board) {\r\n    let _rotatedCells = [];\r\n    for (let _cell of this.cellArray) {\r\n      let _x = this.origin.x - _cell.y;\r\n      let _y = this.origin.y + _cell.x;\r\n      if ((_x >= 10) || (_x < 0)) {\r\n        return false; // outside the bounds\r\n      } else if ((_y >= 20) || (_y < 0)) {\r\n        return false; // outside the bounds\r\n      } else if (board.cells[_y][_x] !== null) {\r\n        return false; // cell already occupied\r\n      } else {\r\n        _rotatedCells.push(\r\n          {x: _cell.y * -1, y: _cell.x}\r\n        ); // _rotatedCells.push\r\n      } // if valid\r\n    } // for _cell of this.cellArray\r\n    this.cellArray = _rotatedCells;\r\n    return true;\r\n  } // rotateCW()\r\n\r\n  rotateCCW(board) {\r\n    let _rotatedCells = [];\r\n    for (let _cell of this.cellArray) {\r\n      let _x = this.origin.x + _cell.y;\r\n      let _y = this.origin.y - _cell.x;\r\n      if ((_x >= 10) || (_x < 0)) {\r\n        return false; // outside the bounds\r\n      } else if ((_y >= 20) || (_y < 0)) {\r\n        return false; // outside the bounds\r\n      } else if (board.cells[_y][_x] !== null) {\r\n        return false; // cell already occupied\r\n      } else {\r\n        _rotatedCells.push(\r\n          {x: _cell.y, y: _cell.x * -1}\r\n        ); // _rotatedCells.push\r\n      } // if valid\r\n    } // for _cell of this.cellArray\r\n    this.cellArray = _rotatedCells;\r\n    return true;\r\n  } // rotateCCW()\r\n\r\n  decompose(board) {\r\n    for (let _cell of this.getCells()) {\r\n      board.cells[_cell.y][_cell.x] = new Tetromino(\r\n        this.name,\r\n        [\r\n          {x: 0, y: 0},\r\n        ],\r\n        this.color,\r\n        {x: _cell.x, y: _cell.y}\r\n      );\r\n    }\r\n  } // decompose()\r\n} // class Tetromino\r\n\r\nTetromino.shape = {\r\n  I: new Tetromino(\r\n    'I',\r\n    [\r\n      {x: -2, y: -1},\r\n      {x: -1, y: -1},\r\n      {x:  0, y: -1},\r\n      {x:  1, y: -1},\r\n    ],\r\n    'Turquoise'\r\n  ), // I\r\n  J: new Tetromino(\r\n    'J',\r\n    [\r\n      {x: -1, y: -1},\r\n      {x: -1, y:  0},\r\n      {x:  0, y:  0},\r\n      {x:  1, y:  0},\r\n    ],\r\n    'RoyalBlue'\r\n  ), // J\r\n  L: new Tetromino(\r\n    'L',\r\n    [\r\n      {x:  1, y: -1},\r\n      {x:  1, y:  0},\r\n      {x:  0, y:  0},\r\n      {x: -1, y:  0},\r\n    ],\r\n    'Tomato'\r\n  ), // L\r\n  O: new Tetromino(\r\n    'O',\r\n    [\r\n      {x: -1, y: -1},\r\n      {x:  0, y: -1},\r\n      {x: -1, y:  0},\r\n      {x:  0, y:  0},\r\n    ],\r\n    'Gold'\r\n  ), // O\r\n  S: new Tetromino(\r\n    'S',\r\n    [\r\n      {x:  1, y: -1},\r\n      {x:  0, y: -1},\r\n      {x:  0, y:  0},\r\n      {x: -1, y:  0},\r\n    ],\r\n    'SeaGreen'\r\n  ), // S\r\n  T: new Tetromino(\r\n    'T',\r\n    [\r\n      {x:  0, y:  0},\r\n      {x:  1, y:  0},\r\n      {x:  0, y: -1},\r\n      {x: -1, y:  0},\r\n    ],\r\n    'HotPink'\r\n  ), // T\r\n  Z: new Tetromino(\r\n    'Z',\r\n    [\r\n      {x:  1, y:  0},\r\n      {x:  0, y:  0},\r\n      {x:  0, y: -1},\r\n      {x: -1, y: -1},\r\n    ],\r\n    'DarkRed'\r\n  ), // Z\r\n  getRandom: function(lastTetromino={name: null}) {\r\n    let _arr = [\r\n      Tetromino.shape.I,\r\n      Tetromino.shape.J,\r\n      Tetromino.shape.L,\r\n      Tetromino.shape.O,\r\n      Tetromino.shape.S,\r\n      Tetromino.shape.T,\r\n      Tetromino.shape.Z\r\n    ]\r\n    let _rand = Math.floor(Math.random() * 7);\r\n    // don't force it not to repeat, just attempt once as a nudge\r\n    // this reduces the chance of repeats from 1/7 to 1/49\r\n    if (lastTetromino.name === _arr[_rand].name) {\r\n      _rand = Math.floor(Math.random() * 7);\r\n    }\r\n    return _arr[_rand].clone();\r\n  },\r\n};\r\n\r\nmodule.exports = Tetromino;\r\n\n\n//# sourceURL=webpack://tetristic/./src/tetromino/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;