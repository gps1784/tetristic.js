/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/board/index.js":
/*!****************************!*\
  !*** ./src/board/index.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Tetromino = __webpack_require__(/*! ../tetromino/index.js */ \"./src/tetromino/index.js\");\r\n\r\nclass Board {\r\n  constructor(canvasObj, scale=20) {\r\n    this.rowCount = 20;\r\n    this.colCount = 10;\r\n    this.context = canvasObj.getContext('2d');\r\n    this.scale   = scale;\r\n    // generate an empty board of cells\r\n    this.cells   = [];\r\n    for (let _row = 0; _row < 20; _row++) {\r\n      this.cells.push([]);\r\n      for (let _col = 0; _col < 10; _col++) {\r\n        this.cells[this.cells.length - 1].push(null);\r\n      } // for _col\r\n    } // for _row\r\n    // generate the upcoming pieces\r\n    this.activeTetromino = Tetromino.shape.getRandom();\r\n    this.nextTetromino   = Tetromino.shape.getRandom(this.activeTetromino);\r\n    // render\r\n    this.renderBackground();\r\n    this.renderForeground();\r\n    this.renderNext();\r\n  } // constructor()\r\n\r\n  renderBackground(scale=this.scale, xLow=0, xHigh=10, yLow=0, yHigh=20) {\r\n    this.context.fillStyle = 'rgb(150, 150, 150)';\r\n    for (let _row = yLow; _row < yHigh; _row++) {\r\n      for (let _col = xLow; _col < xHigh; _col++) {\r\n        let _y = _row * scale;\r\n        let _x = _col * scale;\r\n        this.context.fillRect( _x+1, _y+1, scale-2, scale-2 );\r\n      } // for _col\r\n    } // for _row\r\n  } // renderBackground()\r\n\r\n  renderForeground(scale=this.scale, xLow=0, xHigh=10, yLow=0, yHigh=20) {\r\n    for (let _row = yLow; _row < yHigh; _row++) {\r\n      for (let _col = xLow; _col < xHigh; _col++) {\r\n        let _cell = this.cells[_row][_col];\r\n        if (_cell !== null) {\r\n          _cell.render(this);\r\n        }\r\n      } // for _col\r\n    } // for _row\r\n    this.activeTetromino.render(this);\r\n  } // renderForeground()\r\n\r\n  renderNext(scale=this.scale) {\r\n    this.context.font         = this.scale + 'px monospace';\r\n    this.context.textBaseline = 'bottom';\r\n    this.context.strokeStyle  = 'rgb(150, 150, 150)';\r\n    this.renderBackground(scale, 11, 15, 3, 7);\r\n    this.context.fillText(\"NEXT\", scale*11, scale*3);\r\n    this.nextTetromino.render(this, 13, 5);\r\n  } // renderNext()\r\n\r\n  play() {\r\n    document.onkeydown = this.onKeyDown.bind(this);\r\n    requestAnimationFrame(this.update.bind(this));\r\n  } // play()\r\n\r\n  onKeyDown(event) {\r\n    console.log(`Pressed key: ${event.key}`);\r\n    switch (event.key) {\r\n      case 'q': // CCW\r\n        this.activeTetromino.rotateCCW(this);\r\n        this.update();\r\n      break;\r\n      case 'e': // CW\r\n        this.activeTetromino.rotateCW(this);\r\n        this.update();\r\n      break;\r\n      case 'a':\r\n      case 'ArrowLeft': // left\r\n        this.activeTetromino.translate(this, -1,  0); // dx, dy\r\n        this.update();\r\n      break;\r\n      case 'w':\r\n      case 'ArrowUp': // up\r\n        this.activeTetromino.translate(this,  0, -1); // dx, dy\r\n        this.update();\r\n      break;\r\n      case 'd':\r\n      case 'ArrowRight': // right\r\n        this.activeTetromino.translate(this,  1,  0); // dx, dy\r\n        this.update();\r\n      break;\r\n      case 's':\r\n      case 'ArrowDown': // down\r\n        this.activeTetromino.translate(this,  0,  1); // dx, dy\r\n        this.update();\r\n      break;\r\n    }\r\n  } // onKeyDown()\r\n\r\n  update() {\r\n    // has this tetromino come to rest?\r\n    if (this.activeTetromino.testForLatch(this)) {\r\n      this.activeTetromino.decompose(this);\r\n      this.activeTetromino = null;\r\n    }\r\n    // refill the next tetromino, if needed\r\n    if (this.activeTetromino === null) {\r\n      console.log('getting next tetromino: ' + this.nextTetromino.name);\r\n      this.activeTetromino = this.nextTetromino;\r\n      this.nextTetromino   = Tetromino.shape.getRandom();\r\n    }\r\n    this.renderBackground();\r\n    this.renderForeground();\r\n    this.renderNext();\r\n  } // update()\r\n} // class Board\r\n\r\nmodule.exports = Board;\r\n\n\n//# sourceURL=webpack://tetristic/./src/board/index.js?");

/***/ }),

/***/ "./src/heuristic/index.js":
/*!********************************!*\
  !*** ./src/heuristic/index.js ***!
  \********************************/
/***/ ((module) => {

eval("// tetristic/heuristic/index.js\r\n\r\n// All the heuristics here are normalized.\r\n// That is to say, they are bound to a range of either 0~1 or -1~1\r\n// depending on what is appropriate for our use case.\r\n// I do not want my factors and biases spiraling out of control here,\r\n// so we are normalizing the input of all heuristics.\r\n\r\nconst Heuristic = {\r\n  maxHeight: function heuristicMaxHeight(board) {\r\n    // start at the bottom, counting upward\r\n    // this will keep track of the highest populated row,\r\n    // where 0 is the ceiling and 20 is empty\r\n    let retval = board.rowCount;\r\n    for (var _row = board.rowCount - 1; i > 0; i--) {\r\n      for (let _cell of board.cells[_row]) {\r\n        if (_cell !== null) {\r\n          retval = _row;\r\n        } // if _cell !== null\r\n      } // for _cell\r\n    } // for _row\r\n    // reverse this, then normalize\r\n    // (e.g. row 0 => height 20 => 100% => 1.0)\r\n    retval = (board.rowCount - retval) / board.rowCount;\r\n    return retval;\r\n  }, // maxHeight()\r\n\r\n  list: [], // list\r\n}; // Heuristic\r\n\r\nHeuristic.list.push( Heuristic.maxHeight );\r\n\r\nmodule.exports = Heuristic;\r\n\n\n//# sourceURL=webpack://tetristic/./src/heuristic/index.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("var Tetristic = {};\r\n\r\nTetristic.Board = __webpack_require__(/*! ./board/index.js */ \"./src/board/index.js\");\r\nTetristic.Network = __webpack_require__(/*! ./network/index.js */ \"./src/network/index.js\");\r\n\r\nwindow.onload = function() {\r\n  let board = new Tetristic.Board( document.getElementById('tetristic-board') );\r\n  let network = new Tetristic.Network( document.getElementById('tetristic-network') );\r\n  network.play(board);\r\n};\r\n\n\n//# sourceURL=webpack://tetristic/./src/index.js?");

/***/ }),

/***/ "./src/network/index.js":
/*!******************************!*\
  !*** ./src/network/index.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Heuristic = __webpack_require__(/*! ../heuristic/index.js */ \"./src/heuristic/index.js\");\r\n\r\nclass Network {\r\n  constructor(canvasObj=null, depth=null, widths=null, weights=null, biases=null) {\r\n    this.context = canvasObj.getContext('2d');\r\n    this.generate(depth, widths, weights, biases);\r\n    this.render();\r\n  } // constructor()\r\n\r\n  generate(depth, widths, weights, biases) {\r\n    if (depth === null) {\r\n      this.depth = Math.floor(1 + Math.random() * 3); // 1 <=> 3 layers\r\n    } else {\r\n      this.depth = depth;\r\n    }\r\n\r\n    if (widths === null) {\r\n      this.widths = [];\r\n      let _lastLayerWidth = Heuristic.list.length;\r\n      for (let _layer = 0; _layer < this.depth - 1; _layer++) {\r\n        // this forces a layer to be between x0.5 <=> x1.5 the size of the last\r\n        let _newLayerWidth = Math.max( Math.floor( _lastLayerWidth * (0.5 + Math.random()) ), 2);\r\n        this.widths.push(_newLayerWidth);\r\n        _lastLayerWidth = _newLayerWidth;\r\n      } // for _layer\r\n      this.widths.push(1);\r\n    } else {\r\n      this.widths = widths;\r\n    }\r\n\r\n    if (weights === null) {\r\n      this.weights = [];\r\n      let _lastLayerWidth = Heuristic.list.length;\r\n      for (let _layer = 0; _layer < this.depth; _layer++) {\r\n        this.weights.push( new Array() );\r\n        for (let _node = 0; _node < this.widths[_layer]; _node++) {\r\n          this.weights[_layer].push( new Array() );\r\n          for (let _lastNode = 0; _lastNode < _lastLayerWidth; _lastNode++) {\r\n            this.weights[_layer][_node].push( (Math.random() * 2) - 1 ); // -1 <=> 1\r\n          } // for _lastNode\r\n        } // for _node\r\n        _lastLayerWidth = this.widths[_layer];\r\n      } // for _layer\r\n    } else {\r\n      this.weights = weights;\r\n    }\r\n\r\n    if (biases === null) {\r\n      this.biases = [];\r\n      for (let _layer = 0; _layer < this.depth; _layer++) {\r\n        this.biases.push( new Array() );\r\n        for (let _node = 0; _node < this.widths[_layer]; _node++) {\r\n          this.biases[_layer].push( (Math.random() * 2) - 1 ); // -1 <=> 1\r\n        } // for _node\r\n      } // for _layer\r\n    } else {\r\n      this.biases = biases;\r\n    }\r\n\r\n    // how wide are the graphics for the neural network allowed to be?\r\n    this.widthScale = Math.floor(\r\n      // canvas width divided by the largest of either\r\n      // the widest point in the neural network or the starting inputs\r\n      this.context.canvas.width / Math.max(...this.widths, Heuristic.list.length)\r\n    );\r\n    // how tall are the graphics for the neural network allowed to be?\r\n    this.heightScale = Math.floor(\r\n      // the input and output layers will always be visible, plus any hidden layers\r\n      this.context.canvas.height / (this.depth + 1)\r\n    );\r\n    console.log(this);\r\n  } // generate()\r\n\r\n  render() {\r\n    this.renderLinks();\r\n    this.renderNodes();\r\n  } // render()\r\n\r\n  renderNodes() {\r\n    let scale = Math.min(this.widthScale, this.heightScale);\r\n    let offset = Math.floor(scale / 2);\r\n    // the inputs\r\n    for (let _input = 0; _input < Heuristic.list.length; _input++) {\r\n      let _x = (_input * scale) + offset / 2;\r\n      let _y = offset / 2;\r\n      this.context.lineWidth   = 2;\r\n      this.context.fillStyle   = 'rgb(255, 255, 255)';\r\n      this.context.fillRect(_x+1, _y+1, scale/2 - 2, scale/2 - 2);\r\n      this.context.strokeStyle = 'rgb(0, 0, 0)';\r\n      this.context.strokeRect(_x, _y, scale/2, scale/2);\r\n    } // for _input\r\n    // the hidden/output layers\r\n    for (let _layer = 0; _layer < this.depth; _layer++) {\r\n      for (let _node = 0; _node < this.widths[_layer]; _node++) {\r\n        let _x = (_node * scale) + offset / 2;\r\n        let _y = ((_layer+1) * scale) + offset / 2;\r\n        this.context.lineWidth   = 2;\r\n        this.context.fillStyle   = 'rgb(255, 255, 255)';\r\n        this.context.fillRect(_x+1, _y+1, scale/2 - 2, scale/2 - 2);\r\n        this.context.strokeStyle = 'rgb(0, 0, 0)';\r\n        this.context.strokeRect(_x, _y, scale/2, scale/2);\r\n      } // for _node\r\n    } // for _layer\r\n  } // renderNodes()\r\n\r\n  renderLinks() {\r\n    let scale = Math.min(this.widthScale, this.heightScale);\r\n    let offset = Math.floor(scale / 2);\r\n    for (let _layer = 0; _layer < this.depth; _layer++) {\r\n      for (let _node = 0; _node < this.widths[_layer]; _node++) {\r\n        let _start = {x: _node * scale, y: (_layer + 1) * scale};\r\n        for (let _link = 0; _link < this.weights[_layer][_node].length; _link++) {\r\n          let _end = {x: _link * scale, y: _layer * scale};\r\n          console.log(`line: ${_start.x},${_start.y} <=> ${_end.x},${_end.y} ${this.calcColorRedBlackGreen(this.weights[_layer][_node][_link])}`);\r\n          this.context.lineWidth   = 5;\r\n          this.context.strokeStyle = this.calcColorRedBlackGreen(this.weights[_layer][_node][_link]);\r\n          this.context.beginPath();\r\n          this.context.moveTo(_start.x + offset, _start.y + offset);\r\n          this.context.lineTo(_end.x + offset, _end.y + offset);\r\n          this.context.stroke();\r\n        } // for _link\r\n      } // for _node\r\n    } // for _layer\r\n  } // renderLinks()\r\n\r\n  calcColorRedBlackGreen(decimal) {\r\n    let red   = 0;\r\n    let blue  = 0;\r\n    let green = 0;\r\n    if (decimal < 0) { // red/black (based on 'crimson')\r\n      red   = Math.floor(decimal * -220);\r\n      blue  = Math.floor(decimal *  -20);\r\n      green = Math.floor(decimal *  -60);\r\n\r\n    } else { // green/black (based on 'sea green')\r\n      red   = Math.floor(decimal *  20);\r\n      blue  = Math.floor(decimal * 220);\r\n      green = Math.floor(decimal *  60);\r\n    }\r\n    return `rgb(${red},${blue},${green})`;\r\n  } // calcColorRedBlackGreen()\r\n\r\n  calcColorRedWhiteGreen() {} // calcColorRedWhiteGreen()\r\n\r\n  play(board) {} // play()\r\n} // class Network\r\n\r\nNetwork.heuristic = Heuristic;\r\n\r\nmodule.exports = Network;\r\n\n\n//# sourceURL=webpack://tetristic/./src/network/index.js?");

/***/ }),

/***/ "./src/tetromino/index.js":
/*!********************************!*\
  !*** ./src/tetromino/index.js ***!
  \********************************/
/***/ ((module) => {

eval("const DEFAULT_STARTING_POS = {x: 5, y: 1};\r\n\r\nclass Tetromino {\r\n  constructor(name, cellArray, color='rgb(100, 100, 50)', startingPos=DEFAULT_STARTING_POS) {\r\n    this.name      = name;\r\n    this.origin    = Object.assign({}, startingPos);\r\n    this.cellArray = cellArray;\r\n    this.color     = color;\r\n  } // constructor()\r\n\r\n  clone() {\r\n    return new Tetromino(this.name, this.cellArray, this.color, this.origin);\r\n  } // clone()\r\n\r\n  getCells(x=this.origin.x, y=this.origin.y) {\r\n    let _cells = [];\r\n    for (let _cell of this.cellArray) {\r\n      _cells.push({\r\n        x: _cell.x + x, // column\r\n        y: _cell.y + y, // row\r\n      });\r\n    }\r\n    return _cells;\r\n  } // getCells()\r\n\r\n  render(board, x=this.origin.x, y=this.origin.y) {\r\n    for (let _cell of this.getCells(x, y)) {\r\n      board.context.fillStyle = this.color;\r\n      board.context.fillRect(\r\n        (_cell.x * board.scale) + 1, // x\r\n        (_cell.y * board.scale) + 1, // y\r\n        board.scale - 2, // w\r\n        board.scale - 2  // h\r\n      );\r\n    } // for _cell of getCells()\r\n  } // render()\r\n\r\n  translate(board, dx=0, dy=0) {\r\n    for (let _cell of this.getCells()) {\r\n      if ((_cell.x + dx >= 10) || (_cell.x + dx < 0)) {\r\n        return false;\r\n      } else if ((_cell.y + dy >= 20) || (_cell.y + dy < 0)) {\r\n        return false;\r\n      }\r\n    }\r\n    this.origin.x += dx;\r\n    this.origin.y += dy;\r\n  } // translate()\r\n\r\n  testForLatch(board) {\r\n    for (let _cell of this.getCells()) {\r\n      // if the cell below us is occupied\r\n      if ((_cell.y === 19) || board.cells[_cell.y + 1][_cell.x] !== null) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  } // testForLatch()\r\n\r\n  rotateCW(board) {\r\n    let _rotatedCells = [];\r\n    for (let _cell of this.cellArray) {\r\n      let _x = this.origin.x - _cell.y;\r\n      let _y = this.origin.y + _cell.x;\r\n      if ((_x >= 10) || (_x < 0)) {\r\n        return false; // outside the bounds\r\n      } else if ((_y >= 20) || (_y < 0)) {\r\n        return false; // outside the bounds\r\n      } else {\r\n        _rotatedCells.push(\r\n          {x: _cell.y * -1, y: _cell.x}\r\n        ); // _rotatedCells.push\r\n      } // if valid\r\n    } // for _cell of this.cellArray\r\n    this.cellArray = _rotatedCells;\r\n  } // rotateCW()\r\n\r\n  rotateCCW(board) {\r\n    let _rotatedCells = [];\r\n    for (let _cell of this.cellArray) {\r\n      let _x = this.origin.x + _cell.y;\r\n      let _y = this.origin.y - _cell.x;\r\n      if ((_x >= 10) || (_x < 0)) {\r\n        return false; // outside the bounds\r\n      } else if ((_y >= 20) || (_y < 0)) {\r\n        return false; // outside the bounds\r\n      } else {\r\n        _rotatedCells.push(\r\n          {x: _cell.y, y: _cell.x * -1}\r\n        ); // _rotatedCells.push\r\n      } // if valid\r\n    } // for _cell of this.cellArray\r\n    this.cellArray = _rotatedCells;\r\n  } // rotateCCW()\r\n\r\n  decompose(board) {\r\n    for (let _cell of this.getCells()) {\r\n      board.cells[_cell.y][_cell.x] = new Tetromino(\r\n        this.name,\r\n        [\r\n          {x: 0, y: 0},\r\n        ],\r\n        this.color,\r\n        {x: _cell.x, y: _cell.y}\r\n      );\r\n    }\r\n  } // decompose()\r\n} // class Tetromino\r\n\r\nTetromino.shape = {\r\n  I: new Tetromino(\r\n    'I',\r\n    [\r\n      {x: -2, y: -1},\r\n      {x: -1, y: -1},\r\n      {x:  0, y: -1},\r\n      {x:  1, y: -1},\r\n    ],\r\n    'Turquoise'\r\n  ), // I\r\n  J: new Tetromino(\r\n    'J',\r\n    [\r\n      {x: -1, y: -1},\r\n      {x: -1, y:  0},\r\n      {x:  0, y:  0},\r\n      {x:  1, y:  0},\r\n    ],\r\n    'RoyalBlue'\r\n  ), // J\r\n  L: new Tetromino(\r\n    'L',\r\n    [\r\n      {x:  1, y: -1},\r\n      {x:  1, y:  0},\r\n      {x:  0, y:  0},\r\n      {x: -1, y:  0},\r\n    ],\r\n    'Tomato'\r\n  ), // L\r\n  O: new Tetromino(\r\n    'O',\r\n    [\r\n      {x: -1, y: -1},\r\n      {x:  0, y: -1},\r\n      {x: -1, y:  0},\r\n      {x:  0, y:  0},\r\n    ],\r\n    'Gold'\r\n  ), // O\r\n  S: new Tetromino(\r\n    'S',\r\n    [\r\n      {x:  1, y: -1},\r\n      {x:  0, y: -1},\r\n      {x:  0, y:  0},\r\n      {x: -1, y:  0},\r\n    ],\r\n    'SeaGreen'\r\n  ), // S\r\n  T: new Tetromino(\r\n    'T',\r\n    [\r\n      {x:  0, y:  0},\r\n      {x:  1, y:  0},\r\n      {x:  0, y: -1},\r\n      {x: -1, y:  0},\r\n    ],\r\n    'HotPink'\r\n  ), // T\r\n  Z: new Tetromino(\r\n    'Z',\r\n    [\r\n      {x:  1, y:  0},\r\n      {x:  0, y:  0},\r\n      {x:  0, y: -1},\r\n      {x: -1, y: -1},\r\n    ],\r\n    'DarkRed'\r\n  ), // Z\r\n  getRandom: function(lastTetromino={name: null}) {\r\n    let _arr = [\r\n      Tetromino.shape.I,\r\n      Tetromino.shape.J,\r\n      Tetromino.shape.L,\r\n      Tetromino.shape.O,\r\n      Tetromino.shape.S,\r\n      Tetromino.shape.T,\r\n      Tetromino.shape.Z\r\n    ]\r\n    let _rand = Math.floor(Math.random() * 7);\r\n    // don't force it not to repeat, just attempt once as a nudge\r\n    // this reduces the chance of repeats from 1/7 to 1/49\r\n    if (lastTetromino.name === _arr[_rand].name) {\r\n      _rand = Math.floor(Math.random() * 7);\r\n    }\r\n    return _arr[_rand].clone();\r\n  },\r\n};\r\n\r\nmodule.exports = Tetromino;\r\n\n\n//# sourceURL=webpack://tetristic/./src/tetromino/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;